import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import { Alert } from 'selenium-webdriver';


@Injectable({
  providedIn: 'root'
})
export class ApiService {

  constructor() { }
}

/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.20.1.0 (NJsonSchema v9.11.0.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class Client {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5000";
    }

    /**
     * @param model (optional)
     * @return Success
     */
    register(model: RegistrationViewModel | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Account";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

            let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistration(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRegistration(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param credentials (optional)
     * @return Success
     */
    post2(credentials: CredentialsViewModel | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(credentials);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost2(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPost2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAll(): Observable<BoxMigration[]> {
        let url_ = this.baseUrl + "/api/BoxMigration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<BoxMigration[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BoxMigration[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<BoxMigration[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BoxMigration.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BoxMigration[]>(<any>null);
    }

    /**
     * @param boxMigration (optional)
     * @return Success
     */
    update(boxMigration: BoxMigration | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/BoxMigration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(boxMigration);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param boxMigration (optional)
     * @return Success
     */
    create(boxMigration: BoxMigration | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/BoxMigration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(boxMigration);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    get(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/BoxMigration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/BoxMigration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getListOfCarts(): Observable<Cart[]> {
      let url_ = this.baseUrl + "/api/Cart/Get";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processGet2(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processGet2(<any>response_);
              } catch (e) {
                  return <Observable<Cart[]>><any>_observableThrow(e);
              }
          } else
              return <Observable<Cart[]>><any>_observableThrow(response_);
      }));
  }

  protected processGet2(response: HttpResponseBase): Observable<Cart[]> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
              result200 = [];
              for (let item of resultData200)
                  result200.push(Cart.fromJS(item));
          }
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<Cart[]>(<any>null);
  }

     /**
     * @return Success
     */
    getOwnCart(): Observable<Cart> {
      let url_ = this.baseUrl + "/api/Cart/GetCart";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processGetCart(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processGetCart(<any>response_);
              } catch (e) {
                  return <Observable<Cart>><any>_observableThrow(e);
              }
          } else
              return <Observable<Cart>><any>_observableThrow(response_);
      }));
  }

  protected processGetCart(response: HttpResponseBase): Observable<Cart> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? Cart.fromJS(resultData200) : new Cart();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<Cart>(<any>null);
  }


    /**
     * @return Success
     */
    getCartById(id: number): Observable<Cart> {
      let url_ = this.baseUrl + "/api/Cart/{id}";
      if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processGet3(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processGet3(<any>response_);
              } catch (e) {
                  return <Observable<Cart>><any>_observableThrow(e);
              }
          } else
              return <Observable<Cart>><any>_observableThrow(response_);
      }));
  }

  protected processGet3(response: HttpResponseBase): Observable<Cart> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? Cart.fromJS(resultData200) : new Cart();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<Cart>(<any>null);
  }

    /**
     * @return Success
     */
    deleteCart(id: number): Observable<Cart> {
      let url_ = this.baseUrl + "/api/Cart/{id}";
      if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processDelete2(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processDelete2(<any>response_);
              } catch (e) {
                  return <Observable<Cart>><any>_observableThrow(e);
              }
          } else
              return <Observable<Cart>><any>_observableThrow(response_);
      }));
  }

  protected processDelete2(response: HttpResponseBase): Observable<Cart> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? Cart.fromJS(resultData200) : new Cart();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<Cart>(<any>null);
  }
    /**
     * @param cart (optional)
     * @return Success
     */
    updateCart(cart: Cart | null | undefined): Observable<string> {
       let url_ = this.baseUrl + "/api/Cart";
       url_ = url_.replace(/[?&]$/, "");

       const content_ = JSON.stringify(cart);
       let authToken = localStorage.getItem('auth_token');
       let options_ : any = {
           body: content_,
           observe: "response",
           responseType: "blob",
           headers: new HttpHeaders({
               "Content-Type": "application/json",
               "Accept": "application/json",
               "Authorization": `Bearer ${authToken}`
           })
       };

       return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
           return this.processUpdate2(response_);
       })).pipe(_observableCatch((response_: any) => {
           if (response_ instanceof HttpResponseBase) {
               try {
                   return this.processUpdate2(<any>response_);
               } catch (e) {
                   return <Observable<string>><any>_observableThrow(e);
               }
           } else
               return <Observable<string>><any>_observableThrow(response_);
       }));
   }

   protected processUpdate2(response: HttpResponseBase): Observable<string> {
       const status = response.status;
       const responseBlob =
           response instanceof HttpResponse ? response.body :
           (<any>response).error instanceof Blob ? (<any>response).error : undefined;

       let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
       if (status === 200) {
           return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
           let result200: any = null;
           let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
           result200 = resultData200 !== undefined ? resultData200 : <any>null;
           return _observableOf(result200);
           }));
       } else if (status !== 200 && status !== 204) {
           return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
           return throwException("An unexpected server error occurred.", status, _responseText, _headers);
           }));
       }
       return _observableOf<string>(<any>null);
   }

/**
     * @return Success
     */
    getListOfCartParts(): Observable<CartPart[]> {
      let url_ = this.baseUrl + "/api/CartPart";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processGet4(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processGet4(<any>response_);
              } catch (e) {
                  return <Observable<CartPart[]>><any>_observableThrow(e);
              }
          } else
              return <Observable<CartPart[]>><any>_observableThrow(response_);
      }));
  }

  protected processGet4(response: HttpResponseBase): Observable<CartPart[]> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
              result200 = [];
              for (let item of resultData200)
                  result200.push(CartPart.fromJS(item));
          }
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<CartPart[]>(<any>null);
  }

  /**
   * @param cartPart (optional)
   * @return Success
   */
  updateCartPart(cartPart: CartPart | null | undefined): Observable<CartPart> {
      let url_ = this.baseUrl + "/api/CartPart";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      const content_ = JSON.stringify(cartPart);

      let options_ : any = {
          body: content_,
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Content-Type": "application/json",
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processUndate(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processUndate(<any>response_);
              } catch (e) {
                  return <Observable<CartPart>><any>_observableThrow(e);
              }
          } else
              return <Observable<CartPart>><any>_observableThrow(response_);
      }));
  }

  protected processUndate(response: HttpResponseBase): Observable<CartPart> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? CartPart.fromJS(resultData200) : new CartPart();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<CartPart>(<any>null);
  }

  /**
   * @param cartPart (optional)
   * @return Success
   */
  createCartPart(cartPart: CartPart | null | undefined): Observable<CartPart> {
      let url_ = this.baseUrl + "/api/CartPart";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      const content_ = JSON.stringify(cartPart);
alert(url_);
alert(content_);
      let options_ : any = {
          body: content_,
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Content-Type": "application/json",
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processCreate2(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processCreate2(<any>response_);
              } catch (e) {
                  return <Observable<CartPart>><any>_observableThrow(e);
              }
          } else
              return <Observable<CartPart>><any>_observableThrow(response_);
      }));
  }

  protected processCreate2(response: HttpResponseBase): Observable<CartPart> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? CartPart.fromJS(resultData200) : new CartPart();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<CartPart>(<any>null);
  }

  /**
   * @param menuId (optional)
   * @param cartId (optional)
   * @return Success
   */
  getCartPartById(menuId: number | null | undefined, cartId: number | null | undefined, id: string): Observable<CartPart> {
      let url_ = this.baseUrl + "/api/CartPart/Get/{id}?";
      if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id));
      if (menuId !== undefined)
          url_ += "MenuId=" + encodeURIComponent("" + menuId) + "&";
      if (cartId !== undefined)
          url_ += "CartId=" + encodeURIComponent("" + cartId) + "&";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processGet5(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processGet5(<any>response_);
              } catch (e) {
                  return <Observable<CartPart>><any>_observableThrow(e);
              }
          } else
              return <Observable<CartPart>><any>_observableThrow(response_);
      }));
  }

  protected processGet5(response: HttpResponseBase): Observable<CartPart> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? CartPart.fromJS(resultData200) : new CartPart();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<CartPart>(<any>null);
  }

  /**
   * @param menuId (optional)
   * @param cartId (optional)
   * @return Success
   */
  deleteCartPart(menuId: number | null | undefined, cartId: number | null | undefined, id: string): Observable<CartPart> {
      let url_ = this.baseUrl + "/api/CartPart/Delete{id}?";
      if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id));
      if (menuId !== undefined)
          url_ += "MenuId=" + encodeURIComponent("" + menuId) + "&";
      if (cartId !== undefined)
          url_ += "CartId=" + encodeURIComponent("" + cartId) + "&";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processDelete3(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processDelete3(<any>response_);
              } catch (e) {
                  return <Observable<CartPart>><any>_observableThrow(e);
              }
          } else
              return <Observable<CartPart>><any>_observableThrow(response_);
      }));
  }

  protected processDelete3(response: HttpResponseBase): Observable<CartPart> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? CartPart.fromJS(resultData200) : new CartPart();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<CartPart>(<any>null);
  }

  /**
   * @return Success
   */
  getCartPartByCustomer(id: number): Observable<CartPart[]> {
      let url_ = this.baseUrl + "/api/CartPart/GetCartPartByCustomer/{id}";
      if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processGetCartPartByCustomer(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processGetCartPartByCustomer(<any>response_);
              } catch (e) {
                  return <Observable<CartPart[]>><any>_observableThrow(e);
              }
          } else
              return <Observable<CartPart[]>><any>_observableThrow(response_);
      }));
  }

  protected processGetCartPartByCustomer(response: HttpResponseBase): Observable<CartPart[]> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
              result200 = [];
              for (let item of resultData200)
                  result200.push(CartPart.fromJS(item));
          }
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<CartPart[]>(<any>null);
  }

    /**
     * @return Success
     */
    allowedProductBySpecial(): Observable<Product[]> {
        let url_ = this.baseUrl + "/api/SpecialProduct/AllowedProductBySpecial";
        url_ = url_.replace(/[?&]$/, "");
        let authToken = localStorage.getItem('auth_token');

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json",
                "Authorization": `Bearer ${authToken}`

            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllowedProductBySpecial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllowedProductBySpecial(<any>response_);
                } catch (e) {
                    return <Observable<Product[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Product[]>><any>_observableThrow(response_);
        }));
    }

    protected processAllowedProductBySpecial(response: HttpResponseBase): Observable<Product[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Product.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product[]>(<any>null);
    }

    /**
     * @return Success
     */
    notAllowedProductBySpecial(): Observable<Product[]> {
        let url_ = this.baseUrl + "/api/SpecialProduct/NotAllowedProductBySpecial";
        url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json",
                 "Authorization": `Bearer ${authToken}`

            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotAllowedProductBySpecial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotAllowedProductBySpecial(<any>response_);
                } catch (e) {
                    return <Observable<Product[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Product[]>><any>_observableThrow(response_);
        }));
    }

    protected processNotAllowedProductBySpecial(response: HttpResponseBase): Observable<Product[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Product.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product[]>(<any>null);
    }

    /**
     * @return Success
     */
    get6(): Observable<Customer[]> {
      let url_ = this.baseUrl + "/api/Customer";
      url_ = url_.replace(/[?&]$/, "");

      let authToken = localStorage.getItem('auth_token');

      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processGet6(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processGet6(<any>response_);
              } catch (e) {
                  return <Observable<Customer[]>><any>_observableThrow(e);
              }
          } else
              return <Observable<Customer[]>><any>_observableThrow(response_);
      }));
  }

  protected processGet6(response: HttpResponseBase): Observable<Customer[]> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
              result200 = [];
              for (let item of resultData200)
                  result200.push(Customer.fromJS(item));
          }
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<Customer[]>(<any>null);
  }


     /**
     * @return Success
     */
    getCustomer(): Observable<Customer> {
      let url_ = this.baseUrl + "/api/Customer/GetCustomer";
      url_ = url_.replace(/[?&]$/, "");

      let authToken = localStorage.getItem('auth_token');

      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`

          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processGetCustomer(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processGetCustomer(<any>response_);
              } catch (e) {
                  return <Observable<Customer>><any>_observableThrow(e);
              }
          } else
              return <Observable<Customer>><any>_observableThrow(response_);
      }));
  }

  protected processGetCustomer(response: HttpResponseBase): Observable<Customer> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? Customer.fromJS(resultData200) : new Customer();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<Customer>(<any>null);
  }

    /**
     * @param customer (optional)
     * @return Success
     */
    update3(customer: Customer | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Customer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(customer);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate3(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate3(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @param firstName (optional)
     * @param lastName (optional)
     * @param phone (optional)
     * @param caloricGoal (optional)
     * @param foodStyleId (optional)
     * @param balance (optional)
     * @param isDeleted (optional)
     * @param identityId (optional)
     * @param identity_Id (optional)
     * @param identity_UserName (optional)
     * @param identity_NormalizedUserName (optional)
     * @param identity_Email (optional)
     * @param identity_NormalizedEmail (optional)
     * @param identity_EmailConfirmed (optional)
     * @param identity_PasswordHash (optional)
     * @param identity_SecurityStamp (optional)
     * @param identity_ConcurrencyStamp (optional)
     * @param identity_PhoneNumber (optional)
     * @param identity_PhoneNumberConfirmed (optional)
     * @param identity_TwoFactorEnabled (optional)
     * @param identity_LockoutEnd (optional)
     * @param identity_LockoutEnabled (optional)
     * @param identity_AccessFailedCount (optional)
     * @param foodStyle_Id (optional)
     * @param foodStyle_FoodStyleName (optional)
     * @param foodStyle_CaloricValue (optional)
     * @param foodStyle_Customer (optional)
     * @param foodStyle_FoodStyleProduct (optional)
     * @param cart_CustomerId (optional)
     * @param cart_TotalCaloricValue (optional)
     * @param cart_AddressId (optional)
     * @param cart_MealTimeId (optional)
     * @param cart_DeliveryDate (optional)
     * @param cart_Address_Id (optional)
     * @param cart_Address_Country (optional)
     * @param cart_Address_City (optional)
     * @param cart_Address_Streete (optional)
     * @param cart_Address_HouseNamber (optional)
     * @param cart_Address_FlatNamber (optional)
     * @param cart_Address_Xcoordinate (optional)
     * @param cart_Address_Ycoordinate (optional)
     * @param cart_Address_CustomerId (optional)
     * @param cart_Address_Customer_Id (optional)
     * @param cart_Address_Customer_FirstName (optional)
     * @param cart_Address_Customer_LastName (optional)
     * @param cart_Address_Customer_Phone (optional)
     * @param cart_Address_Customer_CaloricGoal (optional)
     * @param cart_Address_Customer_FoodStyleId (optional)
     * @param cart_Address_Customer_Balance (optional)
     * @param cart_Address_Customer_IsDeleted (optional)
     * @param cart_Address_Customer_IdentityId (optional)
     * @param cart_Address_Customer_Identity (optional)
     * @param cart_Address_Customer_FoodStyle (optional)
     * @param cart_Address_Customer_Cart (optional)
     * @param cart_Address_Customer_DeliveryAddress (optional)
     * @param cart_Address_Customer_FavouriteDish (optional)
     * @param cart_Address_Customer_FoodOrder (optional)
     * @param cart_Address_Customer_SpecialProduct (optional)
     * @param cart_Address_Cart (optional)
     * @param cart_Address_FoodOrder (optional)
     * @param cart_Customer_Id (optional)
     * @param cart_Customer_FirstName (optional)
     * @param cart_Customer_LastName (optional)
     * @param cart_Customer_Phone (optional)
     * @param cart_Customer_CaloricGoal (optional)
     * @param cart_Customer_FoodStyleId (optional)
     * @param cart_Customer_Balance (optional)
     * @param cart_Customer_IsDeleted (optional)
     * @param cart_Customer_IdentityId (optional)
     * @param cart_Customer_Identity (optional)
     * @param cart_Customer_FoodStyle (optional)
     * @param cart_Customer_Cart (optional)
     * @param cart_Customer_DeliveryAddress (optional)
     * @param cart_Customer_FavouriteDish (optional)
     * @param cart_Customer_FoodOrder (optional)
     * @param cart_Customer_SpecialProduct (optional)
     * @param cart_MealTime_Id (optional)
     * @param cart_MealTime_AllowedCaloricValue (optional)
     * @param cart_MealTime_MealTimestamp (optional)
     * @param cart_MealTime_Cart (optional)
     * @param cart_CartPart (optional)
     * @param deliveryAddress (optional)
     * @param favouriteDish (optional)
     * @param foodOrder (optional)
     * @param specialProduct (optional)
     * @return Success
     */
    create3(id: number | null | undefined, firstName: string | null | undefined, lastName: string | null | undefined, phone: number | null | undefined, caloricGoal: number | null | undefined, foodStyleId: number | null | undefined, balance: number | null | undefined, isDeleted: number | null | undefined, identityId: string | null | undefined, identity_Id: string | null | undefined, identity_UserName: string | null | undefined, identity_NormalizedUserName: string | null | undefined, identity_Email: string | null | undefined, identity_NormalizedEmail: string | null | undefined, identity_EmailConfirmed: boolean | null | undefined, identity_PasswordHash: string | null | undefined, identity_SecurityStamp: string | null | undefined, identity_ConcurrencyStamp: string | null | undefined, identity_PhoneNumber: string | null | undefined, identity_PhoneNumberConfirmed: boolean | null | undefined, identity_TwoFactorEnabled: boolean | null | undefined, identity_LockoutEnd: Date | null | undefined, identity_LockoutEnabled: boolean | null | undefined, identity_AccessFailedCount: number | null | undefined, foodStyle_Id: number | null | undefined, foodStyle_FoodStyleName: string | null | undefined, foodStyle_CaloricValue: number | null | undefined, foodStyle_Customer: any[] | null | undefined, foodStyle_FoodStyleProduct: any[] | null | undefined, cart_CustomerId: number | null | undefined, cart_TotalCaloricValue: number | null | undefined, cart_AddressId: number | null | undefined, cart_MealTimeId: number | null | undefined, cart_DeliveryDate: Date | null | undefined, cart_Address_Id: number | null | undefined, cart_Address_Country: string | null | undefined, cart_Address_City: string | null | undefined, cart_Address_Streete: string | null | undefined, cart_Address_HouseNamber: number | null | undefined, cart_Address_FlatNamber: number | null | undefined, cart_Address_Xcoordinate: number | null | undefined, cart_Address_Ycoordinate: number | null | undefined, cart_Address_CustomerId: number | null | undefined, cart_Address_Customer_Id: number | null | undefined, cart_Address_Customer_FirstName: string | null | undefined, cart_Address_Customer_LastName: string | null | undefined, cart_Address_Customer_Phone: number | null | undefined, cart_Address_Customer_CaloricGoal: number | null | undefined, cart_Address_Customer_FoodStyleId: number | null | undefined, cart_Address_Customer_Balance: number | null | undefined, cart_Address_Customer_IsDeleted: number | null | undefined, cart_Address_Customer_IdentityId: string | null | undefined, cart_Address_Customer_Identity: any | null | undefined, cart_Address_Customer_FoodStyle: any | null | undefined, cart_Address_Customer_Cart: any | null | undefined, cart_Address_Customer_DeliveryAddress: any[] | null | undefined, cart_Address_Customer_FavouriteDish: any[] | null | undefined, cart_Address_Customer_FoodOrder: any[] | null | undefined, cart_Address_Customer_SpecialProduct: any[] | null | undefined, cart_Address_Cart: any[] | null | undefined, cart_Address_FoodOrder: any[] | null | undefined, cart_Customer_Id: number | null | undefined, cart_Customer_FirstName: string | null | undefined, cart_Customer_LastName: string | null | undefined, cart_Customer_Phone: number | null | undefined, cart_Customer_CaloricGoal: number | null | undefined, cart_Customer_FoodStyleId: number | null | undefined, cart_Customer_Balance: number | null | undefined, cart_Customer_IsDeleted: number | null | undefined, cart_Customer_IdentityId: string | null | undefined, cart_Customer_Identity: any | null | undefined, cart_Customer_FoodStyle: any | null | undefined, cart_Customer_Cart: any | null | undefined, cart_Customer_DeliveryAddress: any[] | null | undefined, cart_Customer_FavouriteDish: any[] | null | undefined, cart_Customer_FoodOrder: any[] | null | undefined, cart_Customer_SpecialProduct: any[] | null | undefined, cart_MealTime_Id: number | null | undefined, cart_MealTime_AllowedCaloricValue: number | null | undefined, cart_MealTime_MealTimestamp: string | null | undefined, cart_MealTime_Cart: any[] | null | undefined, cart_CartPart: any[] | null | undefined, deliveryAddress: any[] | null | undefined, favouriteDish: any[] | null | undefined, foodOrder: any[] | null | undefined, specialProduct: any[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Customer?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (firstName !== undefined)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&";
        if (lastName !== undefined)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&";
        if (phone !== undefined)
            url_ += "Phone=" + encodeURIComponent("" + phone) + "&";
        if (caloricGoal !== undefined)
            url_ += "CaloricGoal=" + encodeURIComponent("" + caloricGoal) + "&";
        if (foodStyleId !== undefined)
            url_ += "FoodStyleId=" + encodeURIComponent("" + foodStyleId) + "&";
        if (balance !== undefined)
            url_ += "Balance=" + encodeURIComponent("" + balance) + "&";
        if (isDeleted !== undefined)
            url_ += "IsDeleted=" + encodeURIComponent("" + isDeleted) + "&";
        if (identityId !== undefined)
            url_ += "IdentityId=" + encodeURIComponent("" + identityId) + "&";
        if (identity_Id !== undefined)
            url_ += "Identity.Id=" + encodeURIComponent("" + identity_Id) + "&";
        if (identity_UserName !== undefined)
            url_ += "Identity.UserName=" + encodeURIComponent("" + identity_UserName) + "&";
        if (identity_NormalizedUserName !== undefined)
            url_ += "Identity.NormalizedUserName=" + encodeURIComponent("" + identity_NormalizedUserName) + "&";
        if (identity_Email !== undefined)
            url_ += "Identity.Email=" + encodeURIComponent("" + identity_Email) + "&";
        if (identity_NormalizedEmail !== undefined)
            url_ += "Identity.NormalizedEmail=" + encodeURIComponent("" + identity_NormalizedEmail) + "&";
        if (identity_EmailConfirmed !== undefined)
            url_ += "Identity.EmailConfirmed=" + encodeURIComponent("" + identity_EmailConfirmed) + "&";
        if (identity_PasswordHash !== undefined)
            url_ += "Identity.PasswordHash=" + encodeURIComponent("" + identity_PasswordHash) + "&";
        if (identity_SecurityStamp !== undefined)
            url_ += "Identity.SecurityStamp=" + encodeURIComponent("" + identity_SecurityStamp) + "&";
        if (identity_ConcurrencyStamp !== undefined)
            url_ += "Identity.ConcurrencyStamp=" + encodeURIComponent("" + identity_ConcurrencyStamp) + "&";
        if (identity_PhoneNumber !== undefined)
            url_ += "Identity.PhoneNumber=" + encodeURIComponent("" + identity_PhoneNumber) + "&";
        if (identity_PhoneNumberConfirmed !== undefined)
            url_ += "Identity.PhoneNumberConfirmed=" + encodeURIComponent("" + identity_PhoneNumberConfirmed) + "&";
        if (identity_TwoFactorEnabled !== undefined)
            url_ += "Identity.TwoFactorEnabled=" + encodeURIComponent("" + identity_TwoFactorEnabled) + "&";
        if (identity_LockoutEnd !== undefined)
            url_ += "Identity.LockoutEnd=" + encodeURIComponent(identity_LockoutEnd ? "" + identity_LockoutEnd.toJSON() : "") + "&";
        if (identity_LockoutEnabled !== undefined)
            url_ += "Identity.LockoutEnabled=" + encodeURIComponent("" + identity_LockoutEnabled) + "&";
        if (identity_AccessFailedCount !== undefined)
            url_ += "Identity.AccessFailedCount=" + encodeURIComponent("" + identity_AccessFailedCount) + "&";
        if (foodStyle_Id !== undefined)
            url_ += "FoodStyle.Id=" + encodeURIComponent("" + foodStyle_Id) + "&";
        if (foodStyle_FoodStyleName !== undefined)
            url_ += "FoodStyle.FoodStyleName=" + encodeURIComponent("" + foodStyle_FoodStyleName) + "&";
        if (foodStyle_CaloricValue !== undefined)
            url_ += "FoodStyle.CaloricValue=" + encodeURIComponent("" + foodStyle_CaloricValue) + "&";
        if (foodStyle_Customer !== undefined)
            foodStyle_Customer && foodStyle_Customer.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "FoodStyle.Customer[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (foodStyle_FoodStyleProduct !== undefined)
            foodStyle_FoodStyleProduct && foodStyle_FoodStyleProduct.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "FoodStyle.FoodStyleProduct[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (cart_CustomerId !== undefined)
            url_ += "Cart.CustomerId=" + encodeURIComponent("" + cart_CustomerId) + "&";
        if (cart_TotalCaloricValue !== undefined)
            url_ += "Cart.TotalCaloricValue=" + encodeURIComponent("" + cart_TotalCaloricValue) + "&";
        if (cart_AddressId !== undefined)
            url_ += "Cart.AddressId=" + encodeURIComponent("" + cart_AddressId) + "&";
        if (cart_MealTimeId !== undefined)
            url_ += "Cart.MealTimeId=" + encodeURIComponent("" + cart_MealTimeId) + "&";
        if (cart_DeliveryDate !== undefined)
            url_ += "Cart.DeliveryDate=" + encodeURIComponent(cart_DeliveryDate ? "" + cart_DeliveryDate.toJSON() : "") + "&";
        if (cart_Address_Id !== undefined)
            url_ += "Cart.Address.Id=" + encodeURIComponent("" + cart_Address_Id) + "&";
        if (cart_Address_Country !== undefined)
            url_ += "Cart.Address.Country=" + encodeURIComponent("" + cart_Address_Country) + "&";
        if (cart_Address_City !== undefined)
            url_ += "Cart.Address.City=" + encodeURIComponent("" + cart_Address_City) + "&";
        if (cart_Address_Streete !== undefined)
            url_ += "Cart.Address.Streete=" + encodeURIComponent("" + cart_Address_Streete) + "&";
        if (cart_Address_HouseNamber !== undefined)
            url_ += "Cart.Address.HouseNamber=" + encodeURIComponent("" + cart_Address_HouseNamber) + "&";
        if (cart_Address_FlatNamber !== undefined)
            url_ += "Cart.Address.FlatNamber=" + encodeURIComponent("" + cart_Address_FlatNamber) + "&";
        if (cart_Address_Xcoordinate !== undefined)
            url_ += "Cart.Address.Xcoordinate=" + encodeURIComponent("" + cart_Address_Xcoordinate) + "&";
        if (cart_Address_Ycoordinate !== undefined)
            url_ += "Cart.Address.Ycoordinate=" + encodeURIComponent("" + cart_Address_Ycoordinate) + "&";
        if (cart_Address_CustomerId !== undefined)
            url_ += "Cart.Address.CustomerId=" + encodeURIComponent("" + cart_Address_CustomerId) + "&";
        if (cart_Address_Customer_Id !== undefined)
            url_ += "Cart.Address.Customer.Id=" + encodeURIComponent("" + cart_Address_Customer_Id) + "&";
        if (cart_Address_Customer_FirstName !== undefined)
            url_ += "Cart.Address.Customer.FirstName=" + encodeURIComponent("" + cart_Address_Customer_FirstName) + "&";
        if (cart_Address_Customer_LastName !== undefined)
            url_ += "Cart.Address.Customer.LastName=" + encodeURIComponent("" + cart_Address_Customer_LastName) + "&";
        if (cart_Address_Customer_Phone !== undefined)
            url_ += "Cart.Address.Customer.Phone=" + encodeURIComponent("" + cart_Address_Customer_Phone) + "&";
        if (cart_Address_Customer_CaloricGoal !== undefined)
            url_ += "Cart.Address.Customer.CaloricGoal=" + encodeURIComponent("" + cart_Address_Customer_CaloricGoal) + "&";
        if (cart_Address_Customer_FoodStyleId !== undefined)
            url_ += "Cart.Address.Customer.FoodStyleId=" + encodeURIComponent("" + cart_Address_Customer_FoodStyleId) + "&";
        if (cart_Address_Customer_Balance !== undefined)
            url_ += "Cart.Address.Customer.Balance=" + encodeURIComponent("" + cart_Address_Customer_Balance) + "&";
        if (cart_Address_Customer_IsDeleted !== undefined)
            url_ += "Cart.Address.Customer.IsDeleted=" + encodeURIComponent("" + cart_Address_Customer_IsDeleted) + "&";
        if (cart_Address_Customer_IdentityId !== undefined)
            url_ += "Cart.Address.Customer.IdentityId=" + encodeURIComponent("" + cart_Address_Customer_IdentityId) + "&";
        if (cart_Address_Customer_Identity !== undefined)
            url_ += "Cart.Address.Customer.Identity=" + encodeURIComponent("" + cart_Address_Customer_Identity) + "&";
        if (cart_Address_Customer_FoodStyle !== undefined)
            url_ += "Cart.Address.Customer.FoodStyle=" + encodeURIComponent("" + cart_Address_Customer_FoodStyle) + "&";
        if (cart_Address_Customer_Cart !== undefined)
            url_ += "Cart.Address.Customer.Cart=" + encodeURIComponent("" + cart_Address_Customer_Cart) + "&";
        if (cart_Address_Customer_DeliveryAddress !== undefined)
            cart_Address_Customer_DeliveryAddress && cart_Address_Customer_DeliveryAddress.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Cart.Address.Customer.DeliveryAddress[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (cart_Address_Customer_FavouriteDish !== undefined)
            cart_Address_Customer_FavouriteDish && cart_Address_Customer_FavouriteDish.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Cart.Address.Customer.FavouriteDish[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (cart_Address_Customer_FoodOrder !== undefined)
            cart_Address_Customer_FoodOrder && cart_Address_Customer_FoodOrder.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Cart.Address.Customer.FoodOrder[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (cart_Address_Customer_SpecialProduct !== undefined)
            cart_Address_Customer_SpecialProduct && cart_Address_Customer_SpecialProduct.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Cart.Address.Customer.SpecialProduct[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (cart_Address_Cart !== undefined)
            cart_Address_Cart && cart_Address_Cart.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Cart.Address.Cart[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (cart_Address_FoodOrder !== undefined)
            cart_Address_FoodOrder && cart_Address_FoodOrder.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Cart.Address.FoodOrder[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (cart_Customer_Id !== undefined)
            url_ += "Cart.Customer.Id=" + encodeURIComponent("" + cart_Customer_Id) + "&";
        if (cart_Customer_FirstName !== undefined)
            url_ += "Cart.Customer.FirstName=" + encodeURIComponent("" + cart_Customer_FirstName) + "&";
        if (cart_Customer_LastName !== undefined)
            url_ += "Cart.Customer.LastName=" + encodeURIComponent("" + cart_Customer_LastName) + "&";
        if (cart_Customer_Phone !== undefined)
            url_ += "Cart.Customer.Phone=" + encodeURIComponent("" + cart_Customer_Phone) + "&";
        if (cart_Customer_CaloricGoal !== undefined)
            url_ += "Cart.Customer.CaloricGoal=" + encodeURIComponent("" + cart_Customer_CaloricGoal) + "&";
        if (cart_Customer_FoodStyleId !== undefined)
            url_ += "Cart.Customer.FoodStyleId=" + encodeURIComponent("" + cart_Customer_FoodStyleId) + "&";
        if (cart_Customer_Balance !== undefined)
            url_ += "Cart.Customer.Balance=" + encodeURIComponent("" + cart_Customer_Balance) + "&";
        if (cart_Customer_IsDeleted !== undefined)
            url_ += "Cart.Customer.IsDeleted=" + encodeURIComponent("" + cart_Customer_IsDeleted) + "&";
        if (cart_Customer_IdentityId !== undefined)
            url_ += "Cart.Customer.IdentityId=" + encodeURIComponent("" + cart_Customer_IdentityId) + "&";
        if (cart_Customer_Identity !== undefined)
            url_ += "Cart.Customer.Identity=" + encodeURIComponent("" + cart_Customer_Identity) + "&";
        if (cart_Customer_FoodStyle !== undefined)
            url_ += "Cart.Customer.FoodStyle=" + encodeURIComponent("" + cart_Customer_FoodStyle) + "&";
        if (cart_Customer_Cart !== undefined)
            url_ += "Cart.Customer.Cart=" + encodeURIComponent("" + cart_Customer_Cart) + "&";
        if (cart_Customer_DeliveryAddress !== undefined)
            cart_Customer_DeliveryAddress && cart_Customer_DeliveryAddress.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Cart.Customer.DeliveryAddress[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (cart_Customer_FavouriteDish !== undefined)
            cart_Customer_FavouriteDish && cart_Customer_FavouriteDish.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Cart.Customer.FavouriteDish[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (cart_Customer_FoodOrder !== undefined)
            cart_Customer_FoodOrder && cart_Customer_FoodOrder.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Cart.Customer.FoodOrder[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (cart_Customer_SpecialProduct !== undefined)
            cart_Customer_SpecialProduct && cart_Customer_SpecialProduct.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Cart.Customer.SpecialProduct[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (cart_MealTime_Id !== undefined)
            url_ += "Cart.MealTime.Id=" + encodeURIComponent("" + cart_MealTime_Id) + "&";
        if (cart_MealTime_AllowedCaloricValue !== undefined)
            url_ += "Cart.MealTime.AllowedCaloricValue=" + encodeURIComponent("" + cart_MealTime_AllowedCaloricValue) + "&";
        if (cart_MealTime_MealTimestamp !== undefined)
            url_ += "Cart.MealTime.MealTimestamp=" + encodeURIComponent("" + cart_MealTime_MealTimestamp) + "&";
        if (cart_MealTime_Cart !== undefined)
            cart_MealTime_Cart && cart_MealTime_Cart.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Cart.MealTime.Cart[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (cart_CartPart !== undefined)
            cart_CartPart && cart_CartPart.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Cart.CartPart[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (deliveryAddress !== undefined)
            deliveryAddress && deliveryAddress.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "DeliveryAddress[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (favouriteDish !== undefined)
            favouriteDish && favouriteDish.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "FavouriteDish[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (foodOrder !== undefined)
            foodOrder && foodOrder.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "FoodOrder[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (specialProduct !== undefined)
            specialProduct && specialProduct.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "SpecialProduct[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate3(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate3(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    get7(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Customer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet7(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGet7(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    delete4(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Customer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete4(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete4(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    test(): Observable<string> {
        let url_ = this.baseUrl + "/api/Dashboard/Test";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processTest(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    home(): Observable<void> {
        let url_ = this.baseUrl + "/api/Dashboard/Home";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHome(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHome(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processHome(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }


   /**
     * @return Success
     */
    getListOfDeliveryAddresses(): Observable<DeliveryAddress[]> {
      let url_ = this.baseUrl + "/api/DeliveryAddress";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processGet8(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processGet8(<any>response_);
              } catch (e) {
                  return <Observable<DeliveryAddress[]>><any>_observableThrow(e);
              }
          } else
              return <Observable<DeliveryAddress[]>><any>_observableThrow(response_);
      }));
  }

  protected processGet8(response: HttpResponseBase): Observable<DeliveryAddress[]> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
              result200 = [];
              for (let item of resultData200)
                  result200.push(DeliveryAddress.fromJS(item));
          }
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<DeliveryAddress[]>(<any>null);
  }

  /**
   * @param deliveryAddress (optional)
   * @return Success
   */
  updateDeliveryAddress(deliveryAddress: DeliveryAddress | null | undefined): Observable<DeliveryAddress> {
      let url_ = this.baseUrl + "/api/DeliveryAddress";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      const content_ = JSON.stringify(deliveryAddress);

      let options_ : any = {
          body: content_,
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Content-Type": "application/json",
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processUpdate4(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processUpdate4(<any>response_);
              } catch (e) {
                  return <Observable<DeliveryAddress>><any>_observableThrow(e);
              }
          } else
              return <Observable<DeliveryAddress>><any>_observableThrow(response_);
      }));
  }

  protected processUpdate4(response: HttpResponseBase): Observable<DeliveryAddress> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? DeliveryAddress.fromJS(resultData200) : new DeliveryAddress();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<DeliveryAddress>(<any>null);
  }

  /**
   * @param deliveryAddress (optional)
   * @return Success
   */
  createDeliveryAddress(deliveryAddress: DeliveryAddress | null | undefined): Observable<DeliveryAddress> {
      let url_ = this.baseUrl + "/api/DeliveryAddress";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      const content_ = JSON.stringify(deliveryAddress);

      let options_ : any = {
          body: content_,
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Content-Type": "application/json",
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processCreate4(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processCreate4(<any>response_);
              } catch (e) {
                  return <Observable<DeliveryAddress>><any>_observableThrow(e);
              }
          } else
              return <Observable<DeliveryAddress>><any>_observableThrow(response_);
      }));
  }

  protected processCreate4(response: HttpResponseBase): Observable<DeliveryAddress> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? DeliveryAddress.fromJS(resultData200) : new DeliveryAddress();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<DeliveryAddress>(<any>null);
  }

  /**
   * @return Success
   */
  getDeliveryAddressById(id: number): Observable<DeliveryAddress> {
      let url_ = this.baseUrl + "/api/DeliveryAddress/{id}";
      if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processGet9(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processGet9(<any>response_);
              } catch (e) {
                  return <Observable<DeliveryAddress>><any>_observableThrow(e);
              }
          } else
              return <Observable<DeliveryAddress>><any>_observableThrow(response_);
      }));
  }

  protected processGet9(response: HttpResponseBase): Observable<DeliveryAddress> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? DeliveryAddress.fromJS(resultData200) : new DeliveryAddress();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<DeliveryAddress>(<any>null);
  }

  /**
   * @return Success
   */
  deleteDeliveryAddress(id: number): Observable<DeliveryAddress> {
      let url_ = this.baseUrl + "/api/DeliveryAddress/{id}";
      if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processDelete5(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processDelete5(<any>response_);
              } catch (e) {
                  return <Observable<DeliveryAddress>><any>_observableThrow(e);
              }
          } else
              return <Observable<DeliveryAddress>><any>_observableThrow(response_);
      }));
  }

  protected processDelete5(response: HttpResponseBase): Observable<DeliveryAddress> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? DeliveryAddress.fromJS(resultData200) : new DeliveryAddress();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<DeliveryAddress>(<any>null);
  }




    /**
     * @return Success
     */
    get10(): Observable<Dish[]> {
        let url_ = this.baseUrl + "/api/Dish";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet10(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet10(<any>response_);
                } catch (e) {
                    return <Observable<Dish[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dish[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet10(response: HttpResponseBase): Observable<Dish[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Dish.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dish[]>(<any>null);
    }

    /**
     * @param dish (optional)
     * @return Success
     */
    update5(dish: Dish | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Dish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dish);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate5(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate5(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param dish (optional)
     * @return Success
     */
    create5(dish: Dish | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Dish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dish);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate5(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate5(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getDishById(id: number): Observable<Dish> {
       let url_ = this.baseUrl + "/api/Dish/{id}";
       if (id === undefined || id === null)
           throw new Error("The parameter 'id' must be defined.");
       url_ = url_.replace("{id}", encodeURIComponent("" + id));
       url_ = url_.replace(/[?&]$/, "");
       let authToken = localStorage.getItem('auth_token');
       let options_ : any = {
           observe: "response",
           responseType: "blob",
           headers: new HttpHeaders({
               "Accept": "application/json",
               "Authorization": `Bearer ${authToken}`
           })
       };

       return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
           return this.processGet11(response_);
       })).pipe(_observableCatch((response_: any) => {
           if (response_ instanceof HttpResponseBase) {
               try {
                   return this.processGet11(<any>response_);
               } catch (e) {
                   return <Observable<Dish>><any>_observableThrow(e);
               }
           } else
               return <Observable<Dish>><any>_observableThrow(response_);
       }));
   }

   protected processGet11(response: HttpResponseBase): Observable<Dish> {
       const status = response.status;
       const responseBlob =
           response instanceof HttpResponse ? response.body :
           (<any>response).error instanceof Blob ? (<any>response).error : undefined;

       let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
       if (status === 200) {
           return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
           let result200: any = null;
           let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
           result200 = resultData200 ? Dish.fromJS(resultData200) : new Dish();
           return _observableOf(result200);
           }));
       } else if (status !== 200 && status !== 204) {
           return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
           return throwException("An unexpected server error occurred.", status, _responseText, _headers);
           }));
       }
       return _observableOf<Dish>(<any>null);
   }
    /**
     * @return Success
     */
    delete6(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Dish/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete6(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete6(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    get12(): Observable<FavouriteDish[]> {
        let url_ = this.baseUrl + "/api/FavouriteDish";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet12(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet12(<any>response_);
                } catch (e) {
                    return <Observable<FavouriteDish[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FavouriteDish[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet12(response: HttpResponseBase): Observable<FavouriteDish[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FavouriteDish.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FavouriteDish[]>(<any>null);
    }

    /**
     * @param dish (optional)
     * @return Success
     */
    update6(dish: FavouriteDish | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/FavouriteDish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dish);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate6(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate6(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param dish (optional)
     * @return Success
     */
    createFavouriteDish(dish: FavouriteDish | null | undefined): Observable<FavouriteDish> {
         let url_ = this.baseUrl + "/api/FavouriteDish";
         url_ = url_.replace(/[?&]$/, "");
         let authToken = localStorage.getItem('auth_token');

         const content_ = JSON.stringify(dish);

         let options_ : any = {
             body: content_,
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
                 "Content-Type": "application/json",
                 "Accept": "application/json",
                 "Authorization": `Bearer ${authToken}`
             })
         };

         return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
             return this.processCreate6(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
                     return this.processCreate6(<any>response_);
                 } catch (e) {
                     return <Observable<FavouriteDish>><any>_observableThrow(e);
                 }
             } else
                 return <Observable<FavouriteDish>><any>_observableThrow(response_);
         }));
     }

     protected processCreate6(response: HttpResponseBase): Observable<FavouriteDish> {
         const status = response.status;
         const responseBlob =
             response instanceof HttpResponse ? response.body :
             (<any>response).error instanceof Blob ? (<any>response).error : undefined;

         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
         if (status === 200) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
             result200 = resultData200 ? FavouriteDish.fromJS(resultData200) : new FavouriteDish();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
         return _observableOf<FavouriteDish>(<any>null);
     }


    /**
     * @param customerId (optional)
     * @param dishId (optional)
     * @return Success
     */
    get13(customerId: number | null | undefined, dishId: number | null | undefined, id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/FavouriteDish/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (dishId !== undefined)
            url_ += "DishId=" + encodeURIComponent("" + dishId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet13(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet13(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGet13(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param customerId (optional)
     * @param dishId (optional)
     * @return Success
     */
    deleteFavouriteDish(customerId: number | null | undefined, dishId: number | null | undefined, id: string): Observable<FavouriteDish> {
         let url_ = this.baseUrl + "/api/FavouriteDish/Delete?{Id}";
         if (id === undefined || id === null)
             throw new Error("The parameter 'id' must be defined.");
         url_ = url_.replace("{id}", encodeURIComponent("" + id));
         if (customerId !== undefined)
             url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
         if (dishId !== undefined)
             url_ += "DishId=" + encodeURIComponent("" + dishId) + "&";
         url_ = url_.replace(/[?&]$/, "");
         let authToken = localStorage.getItem('auth_token');
         alert(url_);
         let options_ : any = {
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
                 "Accept": "application/json",
                 "Authorization": `Bearer ${authToken}`
             })
         };

         return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
             return this.processDelete7(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
                     return this.processDelete7(<any>response_);
                 } catch (e) {
                     return <Observable<FavouriteDish>><any>_observableThrow(e);
                 }
             } else
                 return <Observable<FavouriteDish>><any>_observableThrow(response_);
         }));
     }

     protected processDelete7(response: HttpResponseBase): Observable<FavouriteDish> {
         const status = response.status;
         const responseBlob =
             response instanceof HttpResponse ? response.body :
             (<any>response).error instanceof Blob ? (<any>response).error : undefined;

         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
         if (status === 200) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
             result200 = resultData200 ? FavouriteDish.fromJS(resultData200) : new FavouriteDish();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
         return _observableOf<FavouriteDish>(<any>null);
     }


        /**
     * @return Success
     */
    pay(orderId: number): Observable<string> {
      let url_ = this.baseUrl + "/api/Financial/Pay/{orderId}";
      if (orderId === undefined || orderId === null)
          throw new Error("The parameter 'orderId' must be defined.");
      url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processPay(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processPay(<any>response_);
              } catch (e) {
                  return <Observable<string>><any>_observableThrow(e);
              }
          } else
              return <Observable<string>><any>_observableThrow(response_);
      }));
  }

  protected processPay(response: HttpResponseBase): Observable<string> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<string>(<any>null);
  }

    /**
     * @return Success
     */
    increaseBalance(customerId: number, moneySum: number): Observable<string> {
      let url_ = this.baseUrl + "/api/Financial/IncreaseBalance/{customerId}, {moneySum}";
      if (customerId === undefined || customerId === null)
          throw new Error("The parameter 'customerId' must be defined.");
      url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
      if (moneySum === undefined || moneySum === null)
          throw new Error("The parameter 'moneySum' must be defined.");
      url_ = url_.replace("{moneySum}", encodeURIComponent("" + moneySum));
      url_ = url_.replace(/[?&]$/, "");
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json"
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processIncreaseBalance(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processIncreaseBalance(<any>response_);
              } catch (e) {
                  return <Observable<string>><any>_observableThrow(e);
              }
          } else
              return <Observable<string>><any>_observableThrow(response_);
      }));
  }

  protected processIncreaseBalance(response: HttpResponseBase): Observable<string> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<string>(<any>null);
  }


  /**
     * @return Success
     */
    changeCaloricGoal(customerId: number, caloricValue: number): Observable<string> {
      let url_ = this.baseUrl + "/api/Customer/ChangeCaloricGoal/{customerId}, {caloricValue}";
      if (customerId === undefined || customerId === null)
          throw new Error("The parameter 'customerId' must be defined.");
      url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
      if (caloricValue === undefined || caloricValue === null)
          throw new Error("The parameter 'caloricValue' must be defined.");
      url_ = url_.replace("{caloricValue}", encodeURIComponent("" + caloricValue));
      url_ = url_.replace(/[?&]$/, "");
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json"
          })
      };
      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processChangeCaloricGoal(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processChangeCaloricGoal(<any>response_);
              } catch (e) {
                  return <Observable<string>><any>_observableThrow(e);
              }
          } else
              return <Observable<string>><any>_observableThrow(response_);
      }));
  }

  protected processChangeCaloricGoal(response: HttpResponseBase): Observable<string> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<string>(<any>null);
  }


  /**
     * @return Success
     */
    changeFirstName(customerId: number, firstName: string): Observable<string> {
      let url_ = this.baseUrl + "/api/Customer/ChangeFirstName/{customerId}, {firstName}";
      if (customerId === undefined || customerId === null)
          throw new Error("The parameter 'customerId' must be defined.");
      url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
      if (firstName === undefined || firstName === null)
          throw new Error("The parameter 'firstName' must be defined.");
      url_ = url_.replace("{firstName}", encodeURIComponent("" + firstName));
      url_ = url_.replace(/[?&]$/, "");
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json"
          })
      };
      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processChangeFirstName(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processChangeFirstName(<any>response_);
              } catch (e) {
                  return <Observable<string>><any>_observableThrow(e);
              }
          } else
              return <Observable<string>><any>_observableThrow(response_);
      }));
  }

  protected processChangeFirstName(response: HttpResponseBase): Observable<string> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<string>(<any>null);
  }

  /**
     * @return Success
     */
    changeLastName(customerId: number, lastName: string): Observable<string> {
      let url_ = this.baseUrl + "/api/Customer/ChangeLastName/{customerId}, {lastName}";
      if (customerId === undefined || customerId === null)
          throw new Error("The parameter 'customerId' must be defined.");
      url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
      if (lastName === undefined || lastName === null)
          throw new Error("The parameter 'lastName' must be defined.");
      url_ = url_.replace("{lastName}", encodeURIComponent("" + lastName));
      url_ = url_.replace(/[?&]$/, "");
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json"
          })
      };
      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processChangeLastName(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processChangeLastName(<any>response_);
              } catch (e) {
                  return <Observable<string>><any>_observableThrow(e);
              }
          } else
              return <Observable<string>><any>_observableThrow(response_);
      }));
  }

  protected processChangeLastName(response: HttpResponseBase): Observable<string> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<string>(<any>null);
  }


  /**
     * @return Success
     */
    changePhoneNumber(customerId: number, phone: number): Observable<string> {
      let url_ = this.baseUrl + "/api/Customer/ChangePhoneNumber/{customerId}, {phone}";
      if (customerId === undefined || customerId === null)
          throw new Error("The parameter 'customerId' must be defined.");
      url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
      if (phone === undefined || phone === null)
          throw new Error("The parameter 'phone' must be defined.");
      url_ = url_.replace("{phone}", encodeURIComponent("" + phone));
      url_ = url_.replace(/[?&]$/, "");
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json"
          })
      };
      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processChangePhoneNumber(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processChangePhoneNumber(<any>response_);
              } catch (e) {
                  return <Observable<string>><any>_observableThrow(e);
              }
          } else
              return <Observable<string>><any>_observableThrow(response_);
      }));
  }

  protected processChangePhoneNumber(response: HttpResponseBase): Observable<string> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<string>(<any>null);
  }


    /**
     * @return Success
     */
    getListOfFoodOrders(): Observable<FoodOrder[]> {
      let url_ = this.baseUrl + "/api/FoodOrder";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processGet14(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processGet14(<any>response_);
              } catch (e) {
                  return <Observable<FoodOrder[]>><any>_observableThrow(e);
              }
          } else
              return <Observable<FoodOrder[]>><any>_observableThrow(response_);
      }));
  }

  protected processGet14(response: HttpResponseBase): Observable<FoodOrder[]> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
              result200 = [];
              for (let item of resultData200)
                  result200.push(FoodOrder.fromJS(item));
          }
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<FoodOrder[]>(<any>null);
  }

    /**
     * @param foodOrder (optional)
     * @return Success
     */
    updateFoodOrder(foodOrder: FoodOrder | null | undefined): Observable<FoodOrder> {
      let url_ = this.baseUrl + "/api/FoodOrder";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      const content_ = JSON.stringify(foodOrder);

      let options_ : any = {
          body: content_,
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Content-Type": "application/json",
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processUpdate7(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processUpdate7(<any>response_);
              } catch (e) {
                  return <Observable<FoodOrder>><any>_observableThrow(e);
              }
          } else
              return <Observable<FoodOrder>><any>_observableThrow(response_);
      }));
  }

  protected processUpdate7(response: HttpResponseBase): Observable<FoodOrder> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? FoodOrder.fromJS(resultData200) : new FoodOrder();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<FoodOrder>(<any>null);
  }

  /**
   * @param foodOrder (optional)
   * @return Success
   */
  createFoodOrder(foodOrder: FoodOrder | null | undefined): Observable<FoodOrder> {
      let url_ = this.baseUrl + "/api/FoodOrder";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      const content_ = JSON.stringify(foodOrder);

      let options_ : any = {
          body: content_,
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Content-Type": "application/json",
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processCreate7(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processCreate7(<any>response_);
              } catch (e) {
                  return <Observable<FoodOrder>><any>_observableThrow(e);
              }
          } else
              return <Observable<FoodOrder>><any>_observableThrow(response_);
      }));
  }

  protected processCreate7(response: HttpResponseBase): Observable<FoodOrder> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? FoodOrder.fromJS(resultData200) : new FoodOrder();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<FoodOrder>(<any>null);
  }

  /**
   * @return Success
   */
  getFoodOrderById(id: number): Observable<FoodOrder> {
      let url_ = this.baseUrl + "/api/FoodOrder/{id}";
      if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processGet15(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processGet15(<any>response_);
              } catch (e) {
                  return <Observable<FoodOrder>><any>_observableThrow(e);
              }
          } else
              return <Observable<FoodOrder>><any>_observableThrow(response_);
      }));
  }

  protected processGet15(response: HttpResponseBase): Observable<FoodOrder> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? FoodOrder.fromJS(resultData200) : new FoodOrder();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<FoodOrder>(<any>null);
  }

  /**
   * @return Success
   */
  deleteFoodOrder(id: number): Observable<FoodOrder> {
      let url_ = this.baseUrl + "/api/FoodOrder/{id}";
      if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processDelete8(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processDelete8(<any>response_);
              } catch (e) {
                  return <Observable<FoodOrder>><any>_observableThrow(e);
              }
          } else
              return <Observable<FoodOrder>><any>_observableThrow(response_);
      }));
  }

  protected processDelete8(response: HttpResponseBase): Observable<FoodOrder> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? FoodOrder.fromJS(resultData200) : new FoodOrder();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<FoodOrder>(<any>null);
  }

        /**
     * @return Success
     */
    changeFoodStyle(customerId: number, foodStyleId: number): Observable<string> {
      let url_ = this.baseUrl + "/api/Customer/ChangeFoodStyle/{customerId}, {foodStyleId}";
      if (customerId === undefined || customerId === null)
          throw new Error("The parameter 'customerId' must be defined.");
      url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
      if (foodStyleId === undefined || foodStyleId === null)
          throw new Error("The parameter 'foodStyleId' must be defined.");
      url_ = url_.replace("{foodStyleId}", encodeURIComponent("" + foodStyleId));
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');

      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processChangeFoodStyle(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processChangeFoodStyle(<any>response_);
              } catch (e) {
                  return <Observable<string>><any>_observableThrow(e);
              }
          } else
              return <Observable<string>><any>_observableThrow(response_);
      }));
  }

  protected processChangeFoodStyle(response: HttpResponseBase): Observable<string> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<string>(<any>null);
  }

  /**
     * @return Success
     */
    productByFoodStyle(foodStyleId: number): Observable<Product[]> {
      let url_ = this.baseUrl + "/api/FoodStyleProduct/ProductByFoodStyle/{foodStyleId}";
      if (foodStyleId === undefined || foodStyleId === null)
          throw new Error("The parameter 'foodStyleId' must be defined.");
      url_ = url_.replace("{foodStyleId}", encodeURIComponent("" + foodStyleId));
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processProductByFoodStyle(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processProductByFoodStyle(<any>response_);
              } catch (e) {
                  return <Observable<Product[]>><any>_observableThrow(e);
              }
          } else
              return <Observable<Product[]>><any>_observableThrow(response_);
      }));
  }

   /**
     * @return Success
     */
    getFavouriteDishesByCustomer(): Observable<Dish[]> {
      let url_ = this.baseUrl + "/api/FavouriteDish/GetFavouriteDishesByCustomer";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processGetFavouriteDishesByCustomer(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processGetFavouriteDishesByCustomer(<any>response_);
              } catch (e) {
                  return <Observable<Dish[]>><any>_observableThrow(e);
              }
          } else
              return <Observable<Dish[]>><any>_observableThrow(response_);
      }));
  }

  protected processGetFavouriteDishesByCustomer(response: HttpResponseBase): Observable<Dish[]> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
              result200 = [];
              for (let item of resultData200)
                  result200.push(Dish.fromJS(item));
          }
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<Dish[]>(<any>null);
  }

  /**
     * @return Success
     */
    getNotFavouriteDishesByCustomer(): Observable<Dish[]> {
      let url_ = this.baseUrl + "/api/FavouriteDish/GetNotFavouriteDishesByCustomer";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processGetNotFavouriteDishesByCustomer(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processGetNotFavouriteDishesByCustomer(<any>response_);
              } catch (e) {
                  return <Observable<Dish[]>><any>_observableThrow(e);
              }
          } else
              return <Observable<Dish[]>><any>_observableThrow(response_);
      }));
  }

  protected processGetNotFavouriteDishesByCustomer(response: HttpResponseBase): Observable<Dish[]> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
              result200 = [];
              for (let item of resultData200)
                  result200.push(Dish.fromJS(item));
          }
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<Dish[]>(<any>null);
  }



  protected processProductByFoodStyle(response: HttpResponseBase): Observable<Product[]> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
              result200 = [];
              for (let item of resultData200)
                  result200.push(Product.fromJS(item));
          }
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<Product[]>(<any>null);
  }

     /**
     * @return Success
     */
    getListOfFoodStyles(): Observable<FoodStyle[]> {
      let url_ = this.baseUrl + "/api/FoodStyle";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processGet16(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processGet16(<any>response_);
              } catch (e) {
                  return <Observable<FoodStyle[]>><any>_observableThrow(e);
              }
          } else
              return <Observable<FoodStyle[]>><any>_observableThrow(response_);
      }));
  }

  protected processGet16(response: HttpResponseBase): Observable<FoodStyle[]> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
              result200 = [];
              for (let item of resultData200)
                  result200.push(FoodStyle.fromJS(item));
          }
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<FoodStyle[]>(<any>null);
  }
/**
     * @param foodStyle (optional)
     * @return Success
     */
    updateFoodStyle(foodStyle: FoodStyle | null | undefined): Observable<FoodStyle> {
      let url_ = this.baseUrl + "/api/FoodStyle";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      const content_ = JSON.stringify(foodStyle);

      let options_ : any = {
          body: content_,
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Content-Type": "application/json",
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processUpdate8(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processUpdate8(<any>response_);
              } catch (e) {
                  return <Observable<FoodStyle>><any>_observableThrow(e);
              }
          } else
              return <Observable<FoodStyle>><any>_observableThrow(response_);
      }));
  }

  protected processUpdate8(response: HttpResponseBase): Observable<FoodStyle> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? FoodStyle.fromJS(resultData200) : new FoodStyle();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<FoodStyle>(<any>null);
  }

  /**
   * @param foodStyle (optional)
   * @return Success
   */
  createFoodStyle(foodStyle: FoodStyle | null | undefined): Observable<FoodStyle> {
      let url_ = this.baseUrl + "/api/FoodStyle";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      const content_ = JSON.stringify(foodStyle);

      let options_ : any = {
          body: content_,
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Content-Type": "application/json",
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processCreate8(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processCreate8(<any>response_);
              } catch (e) {
                  return <Observable<FoodStyle>><any>_observableThrow(e);
              }
          } else
              return <Observable<FoodStyle>><any>_observableThrow(response_);
      }));
  }

  protected processCreate8(response: HttpResponseBase): Observable<FoodStyle> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? FoodStyle.fromJS(resultData200) : new FoodStyle();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<FoodStyle>(<any>null);
  }
 /**
     * @return Success
     */
    deleteCustomersFoodStyle(customerId: number): Observable<string> {
      let url_ = this.baseUrl + "/api/Customer/DeleteCustomersFoodStyle/{customerId}";
      if (customerId === undefined || customerId === null)
          throw new Error("The parameter 'customerId' must be defined.");
      url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processDeleteCustomersFoodStyle(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processDeleteCustomersFoodStyle(<any>response_);
              } catch (e) {
                  return <Observable<string>><any>_observableThrow(e);
              }
          } else
              return <Observable<string>><any>_observableThrow(response_);
      }));
  }

  protected processDeleteCustomersFoodStyle(response: HttpResponseBase): Observable<string> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<string>(<any>null);
  }

   /**
     * @return Success
     */
    getFoodStyleByCustomer(): Observable<FoodStyle> {
      let url_ = this.baseUrl + "/api/FoodStyle/GetByCustomer";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processGetByCustomer(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processGetByCustomer(<any>response_);
              } catch (e) {
                  return <Observable<FoodStyle>><any>_observableThrow(e);
              }
          } else
              return <Observable<FoodStyle>><any>_observableThrow(response_);
      }));
  }

  protected processGetByCustomer(response: HttpResponseBase): Observable<FoodStyle> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? FoodStyle.fromJS(resultData200) : new FoodStyle();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<FoodStyle>(<any>null);
  }


  /**
   * @return Success
   */
  getFoodStyleById(id: number): Observable<FoodStyle> {
      let url_ = this.baseUrl + "/api/FoodStyle/{id}";
      if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processGet17(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processGet17(<any>response_);
              } catch (e) {
                  return <Observable<FoodStyle>><any>_observableThrow(e);
              }
          } else
              return <Observable<FoodStyle>><any>_observableThrow(response_);
      }));
  }

  protected processGet17(response: HttpResponseBase): Observable<FoodStyle> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? FoodStyle.fromJS(resultData200) : new FoodStyle();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<FoodStyle>(<any>null);
  }

  /**
   * @return Success
   */
  deleteFoodStyle(id: number): Observable<FoodStyle> {
      let url_ = this.baseUrl + "/api/FoodStyle/{id}";
      if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');

      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processDelete9(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processDelete9(<any>response_);
              } catch (e) {
                  return <Observable<FoodStyle>><any>_observableThrow(e);
              }
          } else
              return <Observable<FoodStyle>><any>_observableThrow(response_);
      }));
  }

  protected processDelete9(response: HttpResponseBase): Observable<FoodStyle> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? FoodStyle.fromJS(resultData200) : new FoodStyle();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<FoodStyle>(<any>null);
  }

    /**
     * @return Success
     */
    get18(): Observable<FoodStyleProduct[]> {
        let url_ = this.baseUrl + "/api/FoodStyleProduct";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet18(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet18(<any>response_);
                } catch (e) {
                    return <Observable<FoodStyleProduct[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FoodStyleProduct[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet18(response: HttpResponseBase): Observable<FoodStyleProduct[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FoodStyleProduct.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FoodStyleProduct[]>(<any>null);
    }

    /**
     * @param foodStyleProduct (optional)
     * @return Success
     */
    update9(foodStyleProduct: FoodStyleProduct | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/FoodStyleProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(foodStyleProduct);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate9(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate9(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param foodStyleProduct (optional)
     * @return Success
     */
    create9(foodStyleProduct: FoodStyleProduct | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/FoodStyleProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(foodStyleProduct);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate9(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate9(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param foodStyleId (optional)
     * @param productId (optional)
     * @return Success
     */
    get19(foodStyleId: number | null | undefined, productId: number | null | undefined, id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/FoodStyleProduct/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (foodStyleId !== undefined)
            url_ += "FoodStyleId=" + encodeURIComponent("" + foodStyleId) + "&";
        if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet19(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet19(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGet19(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param foodStyleId (optional)
     * @param productId (optional)
     * @return Success
     */
    delete10(foodStyleId: number | null | undefined, productId: number | null | undefined, id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/FoodStyleProduct/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (foodStyleId !== undefined)
            url_ += "FoodStyleId=" + encodeURIComponent("" + foodStyleId) + "&";
        if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete10(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete10(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete10(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    get20(): Observable<Ingredient[]> {
        let url_ = this.baseUrl + "/api/Ingredient";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet20(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet20(<any>response_);
                } catch (e) {
                    return <Observable<Ingredient[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Ingredient[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet20(response: HttpResponseBase): Observable<Ingredient[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Ingredient.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Ingredient[]>(<any>null);
    }

    /**
     * @param ingredient (optional)
     * @return Success
     */
    update10(ingredient: Ingredient | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Ingredient";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ingredient);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate10(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate10(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate10(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ingredient (optional)
     * @return Success
     */
    create10(ingredient: Ingredient | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Ingredient";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ingredient);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate10(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate10(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate10(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param dishId (optional)
     * @param productId (optional)
     * @return Success
     */
    get21(dishId: number | null | undefined, productId: number | null | undefined, id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Ingredient/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (dishId !== undefined)
            url_ += "DishId=" + encodeURIComponent("" + dishId) + "&";
        if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet21(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet21(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGet21(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param dishId (optional)
     * @param productId (optional)
     * @return Success
     */
    delete11(dishId: number | null | undefined, productId: number | null | undefined, id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Ingredient/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (dishId !== undefined)
            url_ += "DishId=" + encodeURIComponent("" + dishId) + "&";
        if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete11(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete11(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete11(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    get22(): Observable<MealTime[]> {
        let url_ = this.baseUrl + "/api/MealTime";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet22(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet22(<any>response_);
                } catch (e) {
                    return <Observable<MealTime[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MealTime[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet22(response: HttpResponseBase): Observable<MealTime[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MealTime.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MealTime[]>(<any>null);
    }

    /**
     * @param mealTime (optional)
     * @return Success
     */
    update11(mealTime: MealTime | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/MealTime";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(mealTime);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate11(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate11(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate11(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param mealTime (optional)
     * @return Success
     */
    create11(mealTime: MealTime | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/MealTime";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(mealTime);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate11(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate11(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate11(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    get23(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/MealTime/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet23(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet23(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGet23(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    delete12(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/MealTime/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete12(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete12(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete12(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param restaurantId (optional)
     * @return Success
     */
    getMenuesByRestaurant(restaurantId: number | null | undefined): Observable<Menu[]> {
      let url_ = this.baseUrl + "/api/Menu/GetMenuesByRestaurant/";
      if (restaurantId !== undefined)
          url_ += encodeURIComponent("" + restaurantId);
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      alert(url_);
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processGetMenuesByRestaurant(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processGetMenuesByRestaurant(<any>response_);
              } catch (e) {
                  return <Observable<Menu[]>><any>_observableThrow(e);
              }
          } else
              return <Observable<Menu[]>><any>_observableThrow(response_);
      }));
  }

  protected processGetMenuesByRestaurant(response: HttpResponseBase): Observable<Menu[]> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
              result200 = [];
              for (let item of resultData200)
                  result200.push(Menu.fromJS(item));
          }
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<Menu[]>(<any>null);
  }


    /**
     * @return Success
     */
    get24(): Observable<Menu[]> {
      let url_ = this.baseUrl + "/api/Menu";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`

          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processGet24(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processGet24(<any>response_);
              } catch (e) {
                  return <Observable<Menu[]>><any>_observableThrow(e);
              }
          } else
              return <Observable<Menu[]>><any>_observableThrow(response_);
      }));
  }

  protected processGet24(response: HttpResponseBase): Observable<Menu[]> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
              result200 = [];
              for (let item of resultData200)
                  result200.push(Menu.fromJS(item));
          }
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<Menu[]>(<any>null);
  }
    /**
     * @param menu (optional)
     * @return Success
     */
    update12(menu: Menu | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Menu";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(menu);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate12(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate12(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate12(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param menu (optional)
     * @return Success
     */
    create12(menu: Menu | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Menu";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(menu);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate12(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate12(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate12(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }


    /**
     * @return Success
     */
    getMenuById(id: number): Observable<Menu> {
      let url_ = this.baseUrl + "/api/Menu/{id}";
      if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`

          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processGet25(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processGet25(<any>response_);
              } catch (e) {
                  return <Observable<Menu>><any>_observableThrow(e);
              }
          } else
              return <Observable<Menu>><any>_observableThrow(response_);
      }));
  }

  protected processGet25(response: HttpResponseBase): Observable<Menu> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? Menu.fromJS(resultData200) : new Menu();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<Menu>(<any>null);
  }

    /**
     * @return Success
     */
    delete13(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Menu/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete13(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete13(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete13(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getProducts(): Observable<Product[]> {
        let url_ = this.baseUrl + "/api/Product";
        url_ = url_.replace(/[?&]$/, "");
        let authToken = localStorage.getItem('auth_token');

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json",
                "Authorization": `Bearer ${authToken}`
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet26(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet26(<any>response_);
                } catch (e) {
                    return <Observable<Product[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Product[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet26(response: HttpResponseBase): Observable<Product[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Product.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product[]>(<any>null);
    }

    /**
     * @param product (optional)
     * @return Success
     */
    update13(product: Product | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(product);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate13(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate13(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate13(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param product (optional)
     * @return Success
     */
    create13(product: Product | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(product);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate13(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate13(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate13(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getProductById(id: number): Observable<Product> {
      let url_ = this.baseUrl + "/api/Product/{id}";
      let authToken = localStorage.getItem('auth_token');

      if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`

          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processGet27(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processGet27(<any>response_);
              } catch (e) {
                  return <Observable<Product>><any>_observableThrow(e);
              }
          } else
              return <Observable<Product>><any>_observableThrow(response_);
      }));
  }

  protected processGet27(response: HttpResponseBase): Observable<Product> {
    const status = response.status;
    const responseBlob =
        response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? Product.fromJS(resultData200) : new Product();
        return _observableOf(result200);
        }));
    } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
    }
    return _observableOf<Product>(<any>null);
}

    /**
     * @return Success
     */
    delete14(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Product/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete14(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete14(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete14(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getListOfRestaurants(): Observable<Restaurant[]> {
       let url_ = this.baseUrl + "/api/Restaurant";
       url_ = url_.replace(/[?&]$/, "");
       let authToken = localStorage.getItem('auth_token');
       let options_ : any = {
           observe: "response",
           responseType: "blob",
           headers: new HttpHeaders({
               "Accept": "application/json",
               "Authorization": `Bearer ${authToken}`
           })
       };

       return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
           return this.processGet28(response_);
       })).pipe(_observableCatch((response_: any) => {
           if (response_ instanceof HttpResponseBase) {
               try {
                   return this.processGet28(<any>response_);
               } catch (e) {
                   return <Observable<Restaurant[]>><any>_observableThrow(e);
               }
           } else
               return <Observable<Restaurant[]>><any>_observableThrow(response_);
       }));
   }

   protected processGet28(response: HttpResponseBase): Observable<Restaurant[]> {
       const status = response.status;
       const responseBlob =
           response instanceof HttpResponse ? response.body :
           (<any>response).error instanceof Blob ? (<any>response).error : undefined;

       let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
       if (status === 200) {
           return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
           let result200: any = null;
           let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
           if (resultData200 && resultData200.constructor === Array) {
               result200 = [];
               for (let item of resultData200)
                   result200.push(Restaurant.fromJS(item));
           }
           return _observableOf(result200);
           }));
       } else if (status !== 200 && status !== 204) {
           return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
           return throwException("An unexpected server error occurred.", status, _responseText, _headers);
           }));
       }
       return _observableOf<Restaurant[]>(<any>null);
   }




    /**
     * @param restaurant (optional)
     * @return Success
     */
    update14(restaurant: Restaurant | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Restaurant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(restaurant);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate14(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate14(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate14(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param restaurant (optional)
     * @return Success
     */
    create14(restaurant: Restaurant | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Restaurant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(restaurant);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate14(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate14(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate14(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRestaurantById(id: number): Observable<Restaurant> {
      let url_ = this.baseUrl + "/api/Restaurant/{id}";
      if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`

          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processGet29(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processGet29(<any>response_);
              } catch (e) {
                  return <Observable<Restaurant>><any>_observableThrow(e);
              }
          } else
              return <Observable<Restaurant>><any>_observableThrow(response_);
      }));
  }

  protected processGet29(response: HttpResponseBase): Observable<Restaurant> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? Restaurant.fromJS(resultData200) : new Restaurant();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<Restaurant>(<any>null);
  }

    /**
     * @return Success
     */
    delete15(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Restaurant/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete15(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete15(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete15(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

         /**
     * @return Success
     */
    findRestaurantsByAppropriate(customerId: number, radius: number, addressId: number): Observable<Restaurant[]> {
      let url_ = this.baseUrl + "/api/Search/Appropriate/{customerId}, {radius}, {addressId}";
      if (customerId === undefined || customerId === null)
          throw new Error("The parameter 'customerId' must be defined.");
      url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
      if (radius === undefined || radius === null)
          throw new Error("The parameter 'radius' must be defined.");
      url_ = url_.replace("{radius}", encodeURIComponent("" + radius));
      if (addressId === undefined || addressId === null)
          throw new Error("The parameter 'addressId' must be defined.");
      url_ = url_.replace("{addressId}", encodeURIComponent("" + addressId));
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processFindRestaurantsByAppropriate(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processFindRestaurantsByAppropriate(<any>response_);
              } catch (e) {
                  return <Observable<Restaurant[]>><any>_observableThrow(e);
              }
          } else
              return <Observable<Restaurant[]>><any>_observableThrow(response_);
      }));
  }

  protected processFindRestaurantsByAppropriate(response: HttpResponseBase): Observable<Restaurant[]> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
              result200 = [];
              for (let item of resultData200)
                  result200.push(Restaurant.fromJS(item));
          }
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<Restaurant[]>(<any>null);
  }
  /**
     * @return Success
     */
    findRestaurantsByAppropriateRuntimePosition(customerId: number, radius: number, xcoordinate: number, ycoordinate: number): Observable<Restaurant[]> {
      let url_ = this.baseUrl + "/api/Search/AppropriateRuntimePosition/{customerId}, {radius}, {Xcoordinate}, {Ycoordinate}";
      if (customerId === undefined || customerId === null)
          throw new Error("The parameter 'customerId' must be defined.");
      url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
      if (radius === undefined || radius === null)
          throw new Error("The parameter 'radius' must be defined.");
      url_ = url_.replace("{radius}", encodeURIComponent("" + radius));
      if (xcoordinate === undefined || xcoordinate === null)
          throw new Error("The parameter 'xcoordinate' must be defined.");
      url_ = url_.replace("{Xcoordinate}", encodeURIComponent("" + xcoordinate));
      if (ycoordinate === undefined || ycoordinate === null)
          throw new Error("The parameter 'ycoordinate' must be defined.");
      url_ = url_.replace("{Ycoordinate}", encodeURIComponent("" + ycoordinate));
      url_ = url_.replace(/[?&]$/, "");

      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json"
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processFindRestaurantsByAppropriateRuntimePosition(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processFindRestaurantsByAppropriateRuntimePosition(<any>response_);
              } catch (e) {
                  return <Observable<Restaurant[]>><any>_observableThrow(e);
              }
          } else
              return <Observable<Restaurant[]>><any>_observableThrow(response_);
      }));
  }

  protected processFindRestaurantsByAppropriateRuntimePosition(response: HttpResponseBase): Observable<Restaurant[]> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
              result200 = [];
              for (let item of resultData200)
                  result200.push(Restaurant.fromJS(item));
          }
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<Restaurant[]>(<any>null);
  }

  /**
   * @return Success
   */
  findRestaurantsByFavourite(customerId: number, radius: number, addressId: number): Observable<Restaurant[]> {
      let url_ = this.baseUrl + "/api/Search/Favourite/{customerId}, {radius}, {addressId}";
      if (customerId === undefined || customerId === null)
          throw new Error("The parameter 'customerId' must be defined.");
      url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
      if (radius === undefined || radius === null)
          throw new Error("The parameter 'radius' must be defined.");
      url_ = url_.replace("{radius}", encodeURIComponent("" + radius));
      if (addressId === undefined || addressId === null)
          throw new Error("The parameter 'addressId' must be defined.");
      url_ = url_.replace("{addressId}", encodeURIComponent("" + addressId));
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processFindRestaurantsByFavourite(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processFindRestaurantsByFavourite(<any>response_);
              } catch (e) {
                  return <Observable<Restaurant[]>><any>_observableThrow(e);
              }
          } else
              return <Observable<Restaurant[]>><any>_observableThrow(response_);
      }));
  }

  protected processFindRestaurantsByFavourite(response: HttpResponseBase): Observable<Restaurant[]> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
              result200 = [];
              for (let item of resultData200)
                  result200.push(Restaurant.fromJS(item));
          }
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<Restaurant[]>(<any>null);
  }

  /**
     * @return Success
     */
    findRestaurantsByFavouriteRuntimePosition(customerId: number, radius: number, xcoordinate: number, ycoordinate: number): Observable<Restaurant[]> {
      let url_ = this.baseUrl + "/api/Search/FavouriteRuntimePosition/{customerId}, {radius}, {Xcoordinate}, {Ycoordinate}";
      if (customerId === undefined || customerId === null)
          throw new Error("The parameter 'customerId' must be defined.");
      url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
      if (radius === undefined || radius === null)
          throw new Error("The parameter 'radius' must be defined.");
      url_ = url_.replace("{radius}", encodeURIComponent("" + radius));
      if (xcoordinate === undefined || xcoordinate === null)
          throw new Error("The parameter 'xcoordinate' must be defined.");
      url_ = url_.replace("{Xcoordinate}", encodeURIComponent("" + xcoordinate));
      if (ycoordinate === undefined || ycoordinate === null)
          throw new Error("The parameter 'ycoordinate' must be defined.");
      url_ = url_.replace("{Ycoordinate}", encodeURIComponent("" + ycoordinate));
      url_ = url_.replace(/[?&]$/, "");

      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json"
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processFindRestaurantsByFavouriteRuntimePosition(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processFindRestaurantsByFavouriteRuntimePosition(<any>response_);
              } catch (e) {
                  return <Observable<Restaurant[]>><any>_observableThrow(e);
              }
          } else
              return <Observable<Restaurant[]>><any>_observableThrow(response_);
      }));
  }

  protected processFindRestaurantsByFavouriteRuntimePosition(response: HttpResponseBase): Observable<Restaurant[]> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
              result200 = [];
              for (let item of resultData200)
                  result200.push(Restaurant.fromJS(item));
          }
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<Restaurant[]>(<any>null);
  }

    /**
     * @return Success
     */
    getSpecialProducts(): Observable<SpecialProduct[]> {
        let url_ = this.baseUrl + "/api/SpecialProduct";
        url_ = url_.replace(/[?&]$/, "");

        let authToken = localStorage.getItem('auth_token');

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json",
                "Authorization": `Bearer ${authToken}`

            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet30(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet30(<any>response_);
                } catch (e) {
                    return <Observable<SpecialProduct[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SpecialProduct[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet30(response: HttpResponseBase): Observable<SpecialProduct[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SpecialProduct.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpecialProduct[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCustomerByToken(): Observable<number> {
        let url_ = this.baseUrl + "/api/Customer/GetCustomerByToken";
        url_ = url_.replace(/[?&]$/, "");
        let authToken = localStorage.getItem('auth_token');

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json",
                "Authorization": `Bearer ${authToken}`

            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerByToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerByToken(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerByToken(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param specialProduct (optional)
     * @return Success
     */
    change(specialProduct: SpecialProduct | null | undefined): Observable<SpecialProduct> {
      let url_ = this.baseUrl + "/api/SpecialProduct";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');


      const content_ = JSON.stringify(specialProduct);

      let options_ : any = {
          body: content_,
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Content-Type": "application/json",
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`

          })
      };

      return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processChange(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processChange(<any>response_);
              } catch (e) {
                  return <Observable<SpecialProduct>><any>_observableThrow(e);
              }
          } else
              return <Observable<SpecialProduct>><any>_observableThrow(response_);
      }));
  }

  protected processChange(response: HttpResponseBase): Observable<SpecialProduct> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? SpecialProduct.fromJS(resultData200) : new SpecialProduct();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<SpecialProduct>(<any>null);
  }



    /**
     * @param productId (optional)
     * @param customerId (optional)
     * @return Success
     */
    get31(productId: number | null | undefined, customerId: number | null | undefined, id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/SpecialProduct/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet31(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet31(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGet31(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param productId (optional)
     * @param customerId (optional)
     * @return Success
     */
    deleteSpecialProduct(productId: number | null | undefined, customerId: number | null | undefined, id: string): Observable<SpecialProduct> {
      let url_ = this.baseUrl + "/api/SpecialProduct/Delete{id}?";
      if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id));
      if (productId !== undefined)
          url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
      if (customerId !== undefined)
          url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processDelete16(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processDelete16(<any>response_);
              } catch (e) {
                  return <Observable<SpecialProduct>><any>_observableThrow(e);
              }
          } else
              return <Observable<SpecialProduct>><any>_observableThrow(response_);
      }));
  }

  protected processDelete16(response: HttpResponseBase): Observable<SpecialProduct> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? SpecialProduct.fromJS(resultData200) : new SpecialProduct();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<SpecialProduct>(<any>null);
  }


    /**
     * @param specialProduct (optional)
     * @return Success
     */
    createAllowed(specialProduct: SpecialProduct | null | undefined): Observable<SpecialProduct> {
      let url_ = this.baseUrl + "/api/SpecialProduct/CreateAllowed";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');

      const content_ = JSON.stringify(specialProduct);

      let options_ : any = {
          body: content_,
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Content-Type": "application/json",
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`

          })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processCreateAllowed(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processCreateAllowed(<any>response_);
              } catch (e) {
                  return <Observable<SpecialProduct>><any>_observableThrow(e);
              }
          } else
              return <Observable<SpecialProduct>><any>_observableThrow(response_);
      }));
  }

  protected processCreateAllowed(response: HttpResponseBase): Observable<SpecialProduct> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? SpecialProduct.fromJS(resultData200) : new SpecialProduct();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<SpecialProduct>(<any>null);
  }

       /**
     * @param specialProduct (optional)
     * @return Success
     */
    createNotAllowed(specialProduct: SpecialProduct | null | undefined): Observable<SpecialProduct> {
      let url_ = this.baseUrl + "/api/SpecialProduct/CreateNotAllowed";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');

      const content_ = JSON.stringify(specialProduct);

      let options_ : any = {
          body: content_,
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Content-Type": "application/json",
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processCreateNotAllowed(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processCreateNotAllowed(<any>response_);
              } catch (e) {
                  return <Observable<SpecialProduct>><any>_observableThrow(e);
              }
          } else
              return <Observable<SpecialProduct>><any>_observableThrow(response_);
      }));
  }

  protected processCreateNotAllowed(response: HttpResponseBase): Observable<SpecialProduct> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? SpecialProduct.fromJS(resultData200) : new SpecialProduct();
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<SpecialProduct>(<any>null);
  }

 /**
     * @return Success
     */
    notSpecialProducts(): Observable<Product[]> {
      let url_ = this.baseUrl + "/api/SpecialProduct/NotSpecialProducts";
      url_ = url_.replace(/[?&]$/, "");
      let authToken = localStorage.getItem('auth_token');
      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "application/json",
              "Authorization": `Bearer ${authToken}`
          })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processNotSpecialProducts(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processNotSpecialProducts(<any>response_);
              } catch (e) {
                  return <Observable<Product[]>><any>_observableThrow(e);
              }
          } else
              return <Observable<Product[]>><any>_observableThrow(response_);
      }));
  }

  protected processNotSpecialProducts(response: HttpResponseBase): Observable<Product[]> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
              result200 = [];
              for (let item of resultData200)
                  result200.push(Product.fromJS(item));
          }
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<Product[]>(<any>null);
  }
}

export class RegistrationViewModel implements IRegistrationViewModel {
    email?: string | undefined;
    password?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phone?: number | undefined;
    role?: string | undefined;

    constructor(data?: IRegistrationViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
            this.password = data["password"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.phone = data["phone"];
            this.role = data["role"];
        }
    }

    static fromJS(data: any): RegistrationViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegistrationViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phone"] = this.phone;
        data["role"] = this.role;
        return data;
    }
}

export interface IRegistrationViewModel {
    email?: string | undefined;
    password?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phone?: number | undefined;
    role?: string | undefined;
}

export class CredentialsViewModel implements ICredentialsViewModel {
    userName?: string | undefined;
    password?: string | undefined;

    constructor(data?: ICredentialsViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): CredentialsViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CredentialsViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface ICredentialsViewModel {
    userName?: string | undefined;
    password?: string | undefined;
}

export class BoxMigration implements IBoxMigration {
    id?: number | undefined;
    latitude?: number | undefined;
    longtitude?: number | undefined;
    moment?: Date | undefined;
    foodOrderId?: number | undefined;
    foodOrder?: FoodOrder | undefined;

    constructor(data?: IBoxMigration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.latitude = data["latitude"];
            this.longtitude = data["longtitude"];
            this.moment = data["moment"] ? new Date(data["moment"].toString()) : <any>undefined;
            this.foodOrderId = data["foodOrderId"];
            this.foodOrder = data["foodOrder"] ? FoodOrder.fromJS(data["foodOrder"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BoxMigration {
        data = typeof data === 'object' ? data : {};
        let result = new BoxMigration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["latitude"] = this.latitude;
        data["longtitude"] = this.longtitude;
        data["moment"] = this.moment ? this.moment.toISOString() : <any>undefined;
        data["foodOrderId"] = this.foodOrderId;
        data["foodOrder"] = this.foodOrder ? this.foodOrder.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBoxMigration {
    id?: number | undefined;
    latitude?: number | undefined;
    longtitude?: number | undefined;
    moment?: Date | undefined;
    foodOrderId?: number | undefined;
    foodOrder?: FoodOrder | undefined;
}

export class FoodOrder implements IFoodOrder {
    id?: number | undefined;
    customerId?: number | undefined;
    totalCost?: number | undefined;
    deliveryDate?: Date | undefined;
    addressId?: number | undefined;
    address?: DeliveryAddress | undefined;
    customer?: Customer | undefined;
    boxMigration?: BoxMigration[] | undefined;

    constructor(data?: IFoodOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.customerId = data["customerId"];
            this.totalCost = data["totalCost"];
            this.deliveryDate = data["deliveryDate"] ? new Date(data["deliveryDate"].toString()) : <any>undefined;
            this.addressId = data["addressId"];
            this.address = data["address"] ? DeliveryAddress.fromJS(data["address"]) : <any>undefined;
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            if (data["boxMigration"] && data["boxMigration"].constructor === Array) {
                this.boxMigration = [];
                for (let item of data["boxMigration"])
                    this.boxMigration.push(BoxMigration.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FoodOrder {
        data = typeof data === 'object' ? data : {};
        let result = new FoodOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerId"] = this.customerId;
        data["totalCost"] = this.totalCost;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toISOString() : <any>undefined;
        data["addressId"] = this.addressId;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        if (this.boxMigration && this.boxMigration.constructor === Array) {
            data["boxMigration"] = [];
            for (let item of this.boxMigration)
                data["boxMigration"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFoodOrder {
    id?: number | undefined;
    customerId?: number | undefined;
    totalCost?: number | undefined;
    deliveryDate?: Date | undefined;
    addressId?: number | undefined;
    address?: DeliveryAddress | undefined;
    customer?: Customer | undefined;
    boxMigration?: BoxMigration[] | undefined;
}

export class DeliveryAddress implements IDeliveryAddress {
    id?: number | undefined;
    country?: string | undefined;
    city?: string | undefined;
    streete?: string | undefined;
    houseNamber?: number | undefined;
    flatNamber?: number | undefined;
    xcoordinate?: number | undefined;
    ycoordinate?: number | undefined;
    customerId?: number | undefined;
    customer?: Customer | undefined;
    cart?: Cart[] | undefined;
    foodOrder?: FoodOrder[] | undefined;

    constructor(data?: IDeliveryAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.country = data["country"];
            this.city = data["city"];
            this.streete = data["streete"];
            this.houseNamber = data["houseNamber"];
            this.flatNamber = data["flatNamber"];
            this.xcoordinate = data["xcoordinate"];
            this.ycoordinate = data["ycoordinate"];
            this.customerId = data["customerId"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            if (data["cart"] && data["cart"].constructor === Array) {
                this.cart = [];
                for (let item of data["cart"])
                    this.cart.push(Cart.fromJS(item));
            }
            if (data["foodOrder"] && data["foodOrder"].constructor === Array) {
                this.foodOrder = [];
                for (let item of data["foodOrder"])
                    this.foodOrder.push(FoodOrder.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeliveryAddress {
        data = typeof data === 'object' ? data : {};
        let result = new DeliveryAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["country"] = this.country;
        data["city"] = this.city;
        data["streete"] = this.streete;
        data["houseNamber"] = this.houseNamber;
        data["flatNamber"] = this.flatNamber;
        data["xcoordinate"] = this.xcoordinate;
        data["ycoordinate"] = this.ycoordinate;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        if (this.cart && this.cart.constructor === Array) {
            data["cart"] = [];
            for (let item of this.cart)
                data["cart"].push(item.toJSON());
        }
        if (this.foodOrder && this.foodOrder.constructor === Array) {
            data["foodOrder"] = [];
            for (let item of this.foodOrder)
                data["foodOrder"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDeliveryAddress {
    id?: number | undefined;
    country?: string | undefined;
    city?: string | undefined;
    streete?: string | undefined;
    houseNamber?: number | undefined;
    flatNamber?: number | undefined;
    xcoordinate?: number | undefined;
    ycoordinate?: number | undefined;
    customerId?: number | undefined;
    customer?: Customer | undefined;
    cart?: Cart[] | undefined;
    foodOrder?: FoodOrder[] | undefined;
}

export class Customer implements ICustomer {
    id?: number | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phone?: number | undefined;
    caloricGoal?: number | undefined;
    foodStyleId?: number | undefined;
    balance?: number | undefined;
    isDeleted?: number | undefined;
    identityId?: string | undefined;
    identity?: User | undefined;
    foodStyle?: FoodStyle | undefined;
    cart?: Cart | undefined;
    deliveryAddress?: DeliveryAddress[] | undefined;
    favouriteDish?: FavouriteDish[] | undefined;
    foodOrder?: FoodOrder[] | undefined;
    specialProduct?: SpecialProduct[] | undefined;

    constructor(data?: ICustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.phone = data["phone"];
            this.caloricGoal = data["caloricGoal"];
            this.foodStyleId = data["foodStyleId"];
            this.balance = data["balance"];
            this.isDeleted = data["isDeleted"];
            this.identityId = data["identityId"];
            this.identity = data["identity"] ? User.fromJS(data["identity"]) : <any>undefined;
            this.foodStyle = data["foodStyle"] ? FoodStyle.fromJS(data["foodStyle"]) : <any>undefined;
            this.cart = data["cart"] ? Cart.fromJS(data["cart"]) : <any>undefined;
            if (data["deliveryAddress"] && data["deliveryAddress"].constructor === Array) {
                this.deliveryAddress = [];
                for (let item of data["deliveryAddress"])
                    this.deliveryAddress.push(DeliveryAddress.fromJS(item));
            }
            if (data["favouriteDish"] && data["favouriteDish"].constructor === Array) {
                this.favouriteDish = [];
                for (let item of data["favouriteDish"])
                    this.favouriteDish.push(FavouriteDish.fromJS(item));
            }
            if (data["foodOrder"] && data["foodOrder"].constructor === Array) {
                this.foodOrder = [];
                for (let item of data["foodOrder"])
                    this.foodOrder.push(FoodOrder.fromJS(item));
            }
            if (data["specialProduct"] && data["specialProduct"].constructor === Array) {
                this.specialProduct = [];
                for (let item of data["specialProduct"])
                    this.specialProduct.push(SpecialProduct.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Customer {
        data = typeof data === 'object' ? data : {};
        let result = new Customer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phone"] = this.phone;
        data["caloricGoal"] = this.caloricGoal;
        data["foodStyleId"] = this.foodStyleId;
        data["balance"] = this.balance;
        data["isDeleted"] = this.isDeleted;
        data["identityId"] = this.identityId;
        data["identity"] = this.identity ? this.identity.toJSON() : <any>undefined;
        data["foodStyle"] = this.foodStyle ? this.foodStyle.toJSON() : <any>undefined;
        data["cart"] = this.cart ? this.cart.toJSON() : <any>undefined;
        if (this.deliveryAddress && this.deliveryAddress.constructor === Array) {
            data["deliveryAddress"] = [];
            for (let item of this.deliveryAddress)
                data["deliveryAddress"].push(item.toJSON());
        }
        if (this.favouriteDish && this.favouriteDish.constructor === Array) {
            data["favouriteDish"] = [];
            for (let item of this.favouriteDish)
                data["favouriteDish"].push(item.toJSON());
        }
        if (this.foodOrder && this.foodOrder.constructor === Array) {
            data["foodOrder"] = [];
            for (let item of this.foodOrder)
                data["foodOrder"].push(item.toJSON());
        }
        if (this.specialProduct && this.specialProduct.constructor === Array) {
            data["specialProduct"] = [];
            for (let item of this.specialProduct)
                data["specialProduct"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICustomer {
    id?: number | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phone?: number | undefined;
    caloricGoal?: number | undefined;
    foodStyleId?: number | undefined;
    balance?: number | undefined;
    isDeleted?: number | undefined;
    identityId?: string | undefined;
    identity?: User | undefined;
    foodStyle?: FoodStyle | undefined;
    cart?: Cart | undefined;
    deliveryAddress?: DeliveryAddress[] | undefined;
    favouriteDish?: FavouriteDish[] | undefined;
    foodOrder?: FoodOrder[] | undefined;
    specialProduct?: SpecialProduct[] | undefined;
}

export class Cart implements ICart {
    customerId?: number | undefined;
    totalCaloricValue?: number | undefined;
    addressId?: number | undefined;
    mealTimeId?: number | undefined;
    deliveryDate?: Date | undefined;
    address?: DeliveryAddress | undefined;
    customer?: Customer | undefined;
    mealTime?: MealTime | undefined;
    cartPart?: CartPart[] | undefined;

    constructor(data?: ICart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerId = data["customerId"];
            this.totalCaloricValue = data["totalCaloricValue"];
            this.addressId = data["addressId"];
            this.mealTimeId = data["mealTimeId"];
            this.deliveryDate = data["deliveryDate"] ? new Date(data["deliveryDate"].toString()) : <any>undefined;
            this.address = data["address"] ? DeliveryAddress.fromJS(data["address"]) : <any>undefined;
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            this.mealTime = data["mealTime"] ? MealTime.fromJS(data["mealTime"]) : <any>undefined;
            if (data["cartPart"] && data["cartPart"].constructor === Array) {
                this.cartPart = [];
                for (let item of data["cartPart"])
                    this.cartPart.push(CartPart.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Cart {
        data = typeof data === 'object' ? data : {};
        let result = new Cart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["totalCaloricValue"] = this.totalCaloricValue;
        data["addressId"] = this.addressId;
        data["mealTimeId"] = this.mealTimeId;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toISOString() : <any>undefined;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["mealTime"] = this.mealTime ? this.mealTime.toJSON() : <any>undefined;
        if (this.cartPart && this.cartPart.constructor === Array) {
            data["cartPart"] = [];
            for (let item of this.cartPart)
                data["cartPart"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICart {
    customerId?: number | undefined;
    totalCaloricValue?: number | undefined;
    addressId?: number | undefined;
    mealTimeId?: number | undefined;
    deliveryDate?: Date | undefined;
    address?: DeliveryAddress | undefined;
    customer?: Customer | undefined;
    mealTime?: MealTime | undefined;
    cartPart?: CartPart[] | undefined;
}

export class User implements IUser {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean | undefined;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean | undefined;
    twoFactorEnabled?: boolean | undefined;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean | undefined;
    accessFailedCount?: number | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userName = data["userName"];
            this.normalizedUserName = data["normalizedUserName"];
            this.email = data["email"];
            this.normalizedEmail = data["normalizedEmail"];
            this.emailConfirmed = data["emailConfirmed"];
            this.passwordHash = data["passwordHash"];
            this.securityStamp = data["securityStamp"];
            this.concurrencyStamp = data["concurrencyStamp"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneNumberConfirmed = data["phoneNumberConfirmed"];
            this.twoFactorEnabled = data["twoFactorEnabled"];
            this.lockoutEnd = data["lockoutEnd"] ? new Date(data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = data["lockoutEnabled"];
            this.accessFailedCount = data["accessFailedCount"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        return data;
    }
}

export interface IUser {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean | undefined;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean | undefined;
    twoFactorEnabled?: boolean | undefined;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean | undefined;
    accessFailedCount?: number | undefined;
}

export class FoodStyle implements IFoodStyle {
    id?: number | undefined;
    foodStyleName?: string | undefined;
    caloricValue?: number | undefined;
    customer?: Customer[] | undefined;
    foodStyleProduct?: FoodStyleProduct[] | undefined;

    constructor(data?: IFoodStyle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.foodStyleName = data["foodStyleName"];
            this.caloricValue = data["caloricValue"];
            if (data["customer"] && data["customer"].constructor === Array) {
                this.customer = [];
                for (let item of data["customer"])
                    this.customer.push(Customer.fromJS(item));
            }
            if (data["foodStyleProduct"] && data["foodStyleProduct"].constructor === Array) {
                this.foodStyleProduct = [];
                for (let item of data["foodStyleProduct"])
                    this.foodStyleProduct.push(FoodStyleProduct.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FoodStyle {
        data = typeof data === 'object' ? data : {};
        let result = new FoodStyle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["foodStyleName"] = this.foodStyleName;
        data["caloricValue"] = this.caloricValue;
        if (this.customer && this.customer.constructor === Array) {
            data["customer"] = [];
            for (let item of this.customer)
                data["customer"].push(item.toJSON());
        }
        if (this.foodStyleProduct && this.foodStyleProduct.constructor === Array) {
            data["foodStyleProduct"] = [];
            for (let item of this.foodStyleProduct)
                data["foodStyleProduct"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFoodStyle {
    id?: number | undefined;
    foodStyleName?: string | undefined;
    caloricValue?: number | undefined;
    customer?: Customer[] | undefined;
    foodStyleProduct?: FoodStyleProduct[] | undefined;
}

export class FavouriteDish implements IFavouriteDish {
    customerId?: number | undefined;
    dishId?: number | undefined;
    customer?: Customer | undefined;
    dish?: Dish | undefined;

    constructor(data?: IFavouriteDish) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerId = data["customerId"];
            this.dishId = data["dishId"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            this.dish = data["dish"] ? Dish.fromJS(data["dish"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FavouriteDish {
        data = typeof data === 'object' ? data : {};
        let result = new FavouriteDish();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["dishId"] = this.dishId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["dish"] = this.dish ? this.dish.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFavouriteDish {
    customerId?: number | undefined;
    dishId?: number | undefined;
    customer?: Customer | undefined;
    dish?: Dish | undefined;
}

export class SpecialProduct implements ISpecialProduct {
    productId?: number | undefined;
    customerId?: number | undefined;
    allowance?: number | undefined;
    customer?: Customer | undefined;
    product?: Product | undefined;

    constructor(data?: ISpecialProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.productId = data["productId"];
            this.customerId = data["customerId"];
            this.allowance = data["allowance"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            this.product = data["product"] ? Product.fromJS(data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SpecialProduct {
        data = typeof data === 'object' ? data : {};
        let result = new SpecialProduct();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["customerId"] = this.customerId;
        data["allowance"] = this.allowance;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISpecialProduct {
    productId?: number | undefined;
    customerId?: number | undefined;
    allowance?: number | undefined;
    customer?: Customer | undefined;
    product?: Product | undefined;
}

export class MealTime implements IMealTime {
    id?: number | undefined;
    allowedCaloricValue?: number | undefined;
    mealTimestamp?: string | undefined;
    cart?: Cart[] | undefined;

    constructor(data?: IMealTime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.allowedCaloricValue = data["allowedCaloricValue"];
            this.mealTimestamp = data["mealTimestamp"];
            if (data["cart"] && data["cart"].constructor === Array) {
                this.cart = [];
                for (let item of data["cart"])
                    this.cart.push(Cart.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MealTime {
        data = typeof data === 'object' ? data : {};
        let result = new MealTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["allowedCaloricValue"] = this.allowedCaloricValue;
        data["mealTimestamp"] = this.mealTimestamp;
        if (this.cart && this.cart.constructor === Array) {
            data["cart"] = [];
            for (let item of this.cart)
                data["cart"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMealTime {
    id?: number | undefined;
    allowedCaloricValue?: number | undefined;
    mealTimestamp?: string | undefined;
    cart?: Cart[] | undefined;
}

export class CartPart implements ICartPart {
    menuId?: number | undefined;
    cartId?: number | undefined;
    dishCount?: number | undefined;
    dishTemperature?: number | undefined;
    cart?: Cart | undefined;
    menu?: Menu | undefined;

    constructor(data?: ICartPart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.menuId = data["menuId"];
            this.cartId = data["cartId"];
            this.dishCount = data["dishCount"];
            this.dishTemperature = data["dishTemperature"];
            this.cart = data["cart"] ? Cart.fromJS(data["cart"]) : <any>undefined;
            this.menu = data["menu"] ? Menu.fromJS(data["menu"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CartPart {
        data = typeof data === 'object' ? data : {};
        let result = new CartPart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuId"] = this.menuId;
        data["cartId"] = this.cartId;
        data["dishCount"] = this.dishCount;
        data["dishTemperature"] = this.dishTemperature;
        data["cart"] = this.cart ? this.cart.toJSON() : <any>undefined;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICartPart {
    menuId?: number | undefined;
    cartId?: number | undefined;
    dishCount?: number | undefined;
    dishTemperature?: number | undefined;
    cart?: Cart | undefined;
    menu?: Menu | undefined;
}

export class FoodStyleProduct implements IFoodStyleProduct {
    foodStyleId?: number | undefined;
    productId?: number | undefined;
    foodStyle?: FoodStyle | undefined;
    product?: Product | undefined;

    constructor(data?: IFoodStyleProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.foodStyleId = data["foodStyleId"];
            this.productId = data["productId"];
            this.foodStyle = data["foodStyle"] ? FoodStyle.fromJS(data["foodStyle"]) : <any>undefined;
            this.product = data["product"] ? Product.fromJS(data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FoodStyleProduct {
        data = typeof data === 'object' ? data : {};
        let result = new FoodStyleProduct();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foodStyleId"] = this.foodStyleId;
        data["productId"] = this.productId;
        data["foodStyle"] = this.foodStyle ? this.foodStyle.toJSON() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFoodStyleProduct {
    foodStyleId?: number | undefined;
    productId?: number | undefined;
    foodStyle?: FoodStyle | undefined;
    product?: Product | undefined;
}

export class Dish implements IDish {
    id?: number | undefined;
    dishName?: string | undefined;
    dishDescription?: string | undefined;
    favouriteDish?: FavouriteDish[] | undefined;
    ingredient?: Ingredient[] | undefined;
    menu?: Menu[] | undefined;

    constructor(data?: IDish) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.dishName = data["dishName"];
            this.dishDescription = data["dishDescription"];
            if (data["favouriteDish"] && data["favouriteDish"].constructor === Array) {
                this.favouriteDish = [];
                for (let item of data["favouriteDish"])
                    this.favouriteDish.push(FavouriteDish.fromJS(item));
            }
            if (data["ingredient"] && data["ingredient"].constructor === Array) {
                this.ingredient = [];
                for (let item of data["ingredient"])
                    this.ingredient.push(Ingredient.fromJS(item));
            }
            if (data["menu"] && data["menu"].constructor === Array) {
                this.menu = [];
                for (let item of data["menu"])
                    this.menu.push(Menu.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Dish {
        data = typeof data === 'object' ? data : {};
        let result = new Dish();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dishName"] = this.dishName;
        data["dishDescription"] = this.dishDescription;
        if (this.favouriteDish && this.favouriteDish.constructor === Array) {
            data["favouriteDish"] = [];
            for (let item of this.favouriteDish)
                data["favouriteDish"].push(item.toJSON());
        }
        if (this.ingredient && this.ingredient.constructor === Array) {
            data["ingredient"] = [];
            for (let item of this.ingredient)
                data["ingredient"].push(item.toJSON());
        }
        if (this.menu && this.menu.constructor === Array) {
            data["menu"] = [];
            for (let item of this.menu)
                data["menu"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDish {
    id?: number | undefined;
    dishName?: string | undefined;
    dishDescription?: string | undefined;
    favouriteDish?: FavouriteDish[] | undefined;
    ingredient?: Ingredient[] | undefined;
    menu?: Menu[] | undefined;
}

export class Product implements IProduct {
    id?: number | undefined;
    productName?: string | undefined;
    caloricValue?: number | undefined;
    foodStyleProduct?: FoodStyleProduct[] | undefined;
    ingredient?: Ingredient[] | undefined;
    specialProduct?: SpecialProduct[] | undefined;

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.productName = data["productName"];
            this.caloricValue = data["caloricValue"];
            if (data["foodStyleProduct"] && data["foodStyleProduct"].constructor === Array) {
                this.foodStyleProduct = [];
                for (let item of data["foodStyleProduct"])
                    this.foodStyleProduct.push(FoodStyleProduct.fromJS(item));
            }
            if (data["ingredient"] && data["ingredient"].constructor === Array) {
                this.ingredient = [];
                for (let item of data["ingredient"])
                    this.ingredient.push(Ingredient.fromJS(item));
            }
            if (data["specialProduct"] && data["specialProduct"].constructor === Array) {
                this.specialProduct = [];
                for (let item of data["specialProduct"])
                    this.specialProduct.push(SpecialProduct.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productName"] = this.productName;
        data["caloricValue"] = this.caloricValue;
        if (this.foodStyleProduct && this.foodStyleProduct.constructor === Array) {
            data["foodStyleProduct"] = [];
            for (let item of this.foodStyleProduct)
                data["foodStyleProduct"].push(item.toJSON());
        }
        if (this.ingredient && this.ingredient.constructor === Array) {
            data["ingredient"] = [];
            for (let item of this.ingredient)
                data["ingredient"].push(item.toJSON());
        }
        if (this.specialProduct && this.specialProduct.constructor === Array) {
            data["specialProduct"] = [];
            for (let item of this.specialProduct)
                data["specialProduct"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProduct {
    id?: number | undefined;
    productName?: string | undefined;
    caloricValue?: number | undefined;
    foodStyleProduct?: FoodStyleProduct[] | undefined;
    ingredient?: Ingredient[] | undefined;
    specialProduct?: SpecialProduct[] | undefined;
}

export class Menu implements IMenu {
    id?: number | undefined;
    dishId?: number | undefined;
    restaurantId?: number | undefined;
    cost?: number | undefined;
    dish?: Dish | undefined;
    restaurant?: Restaurant | undefined;
    cartPart?: CartPart[] | undefined;

    constructor(data?: IMenu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.dishId = data["dishId"];
            this.restaurantId = data["restaurantId"];
            this.cost = data["cost"];
            this.dish = data["dish"] ? Dish.fromJS(data["dish"]) : <any>undefined;
            this.restaurant = data["restaurant"] ? Restaurant.fromJS(data["restaurant"]) : <any>undefined;
            if (data["cartPart"] && data["cartPart"].constructor === Array) {
                this.cartPart = [];
                for (let item of data["cartPart"])
                    this.cartPart.push(CartPart.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Menu {
        data = typeof data === 'object' ? data : {};
        let result = new Menu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dishId"] = this.dishId;
        data["restaurantId"] = this.restaurantId;
        data["cost"] = this.cost;
        data["dish"] = this.dish ? this.dish.toJSON() : <any>undefined;
        data["restaurant"] = this.restaurant ? this.restaurant.toJSON() : <any>undefined;
        if (this.cartPart && this.cartPart.constructor === Array) {
            data["cartPart"] = [];
            for (let item of this.cartPart)
                data["cartPart"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMenu {
    id?: number | undefined;
    dishId?: number | undefined;
    restaurantId?: number | undefined;
    cost?: number | undefined;
    dish?: Dish | undefined;
    restaurant?: Restaurant | undefined;
    cartPart?: CartPart[] | undefined;
}

export class Ingredient implements IIngredient {
    dishId?: number | undefined;
    productId?: number | undefined;
    productWeight?: number | undefined;
    dish?: Dish | undefined;
    product?: Product | undefined;

    constructor(data?: IIngredient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dishId = data["dishId"];
            this.productId = data["productId"];
            this.productWeight = data["productWeight"];
            this.dish = data["dish"] ? Dish.fromJS(data["dish"]) : <any>undefined;
            this.product = data["product"] ? Product.fromJS(data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Ingredient {
        data = typeof data === 'object' ? data : {};
        let result = new Ingredient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dishId"] = this.dishId;
        data["productId"] = this.productId;
        data["productWeight"] = this.productWeight;
        data["dish"] = this.dish ? this.dish.toJSON() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIngredient {
    dishId?: number | undefined;
    productId?: number | undefined;
    productWeight?: number | undefined;
    dish?: Dish | undefined;
    product?: Product | undefined;
}

export class Restaurant implements IRestaurant {
    id?: number | undefined;
    restaurantName?: string | undefined;
    country?: string | undefined;
    city?: string | undefined;
    streete?: string | undefined;
    houseNamber?: number | undefined;
    xcoordinate?: number | undefined;
    ycoordinate?: number | undefined;
    isDeleted?: number | undefined;
    menu?: Menu[] | undefined;

    constructor(data?: IRestaurant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.restaurantName = data["restaurantName"];
            this.country = data["country"];
            this.city = data["city"];
            this.streete = data["streete"];
            this.houseNamber = data["houseNamber"];
            this.xcoordinate = data["xcoordinate"];
            this.ycoordinate = data["ycoordinate"];
            this.isDeleted = data["isDeleted"];
            if (data["menu"] && data["menu"].constructor === Array) {
                this.menu = [];
                for (let item of data["menu"])
                    this.menu.push(Menu.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Restaurant {
        data = typeof data === 'object' ? data : {};
        let result = new Restaurant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["restaurantName"] = this.restaurantName;
        data["country"] = this.country;
        data["city"] = this.city;
        data["streete"] = this.streete;
        data["houseNamber"] = this.houseNamber;
        data["xcoordinate"] = this.xcoordinate;
        data["ycoordinate"] = this.ycoordinate;
        data["isDeleted"] = this.isDeleted;
        if (this.menu && this.menu.constructor === Array) {
            data["menu"] = [];
            for (let item of this.menu)
                data["menu"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRestaurant {
    id?: number | undefined;
    restaurantName?: string | undefined;
    country?: string | undefined;
    city?: string | undefined;
    streete?: string | undefined;
    houseNamber?: number | undefined;
    xcoordinate?: number | undefined;
    ycoordinate?: number | undefined;
    isDeleted?: number | undefined;
    menu?: Menu[] | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = function() {
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob);
        }
    });
  }
